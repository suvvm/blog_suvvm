---
title: SPFA原理分析
date: 2019-11-13 08:13:28
categories: 
- 算法相关
tags:
- 最短路
mathjax: true
---
## SPFA原理分析

### 贝尔曼 福特算法时间复杂度

针对N个顶点E条边的连通图，由于Bellman Ford算法需要对所有的边遍历N-1次后再添加一次额外的遍历([详见](https://www.suvvm.work/2019/11/12/Bellman-Ford原理分析/))，其时间复杂度为 $ O(N\times E)$ 。这个复杂度依旧不尽人意，现在要对其进行优化，之前针对贝尔曼 福特算法的分析中指出，如果最短路存在，松弛操作的次数不会超过N-1，正因如此，每个点被优化的次数也不会超过N-1，且只有当某个顶点u到源点的最短距离发生改变，它所发出的边所指向的另外一点v到源点的最短路才有可能会发生改变。

### 进行优化

以上方思想为指导进行优化，初始将源点到所有顶点最短路距离视为无穷大，之后维护一个队列，每次将队首的顶点u取出，对从u出发的所有边进行遍历，如果u可以使边另一端的顶点v到达源点的最短距离缩短，则进行优化操作，如果当前v不在队列中则将v入队，这样一旦队列为空时证明所有的优化已经完成，便可以成功获得源点到所有点的最短路长度，而一旦某个点被优化的次数超过N-1则说明给出的图中有从源点可达的负环。

### 模拟SPFA运行过程

以下图为例，进行一次SPFA运行过程的模拟。

![img](spfa1-1.svg)

以A为起点，依旧用其他最短路算法一样，将初始状态的，源点到所有点之间的最短距离视为无穷大。

#### 优化源点

记录源点到其本身的距离为0，并将其入队。

![img](spfa1-2.svg)

此时队列中的点

| A    |
| ---- |
| 0    |

当前A点到所有点的最短路长度表

| A    | B    | C    | D    | E    | F    |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 0    | ∞    | ∞    | ∞    | ∞    | ∞    |

#### 第一次优化

将队首的元素A出队，遍历所有以A为起点的边

以A为起点的边有权值为2的$A\rightarrow B$与权值为3的$A\rightarrow C$

```
边A(0)	2	B(∞)	将B点到源点的最短距离由无穷大优化为0+2=2
边A(0)	3	C(∞)	将C点到源点的最短距离由无穷大优化为0+2=3
```

将被优化的B点和C点入队

![img](spfa1-3.svg)

此时队列中的点

| B    | C    |
| ---- | ---- |
| 2    | 3    |

当前A点到所有点的最短路长度表

| A    | B    | C    | D    | E    | F    |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 0    | 2    | 3    | ∞    | ∞    | ∞    |

#### 第二次优化

将队首的元素B出队，遍历所有以B为起点的边

以B为起点的边有权值为6的$B\rightarrow E$

```
边B(2)	6	E(∞)	将E点到源点的最短距离由无穷大优化为2+6=8
```

将被优化的E点入队

![img](spfa1-4.svg)

此时队列中的点

| C    | E    |
| ---- | ---- |
| 3    | 8    |

当前A点到所有点的最短路长度表

| A    | B    | C    | D    | E    | F    |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 0    | 2    | 3    | ∞    | 8    | ∞    |

#### 第三次优化

将队首的元素C出队，遍历所有以C为起点的边

以B为起点的边有权值为-2的$C\rightarrow B$与权值为5的$C\rightarrow E$

```
边C(3)	-2	B(2)	将B点到源点的最短距离由无穷大优化为3-2=1
边C(3)	5	E(8)	并不能进行优化
```

将被优化的B点入队

![img](spfa1-5.svg)

此时队列中的点

| E    | B    |
| ---- | ---- |
| 8    | 1    |

当前A点到所有点的最短路长度表

| A    | B    | C    | D    | E    | F    |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 0    | 1    | 3    | ∞    | 8    | ∞    |

#### 第四次优化

将队首的元素E出队，遍历所有以E为起点的边

以E为起点的边有权值为-5的$E\rightarrow D$与权值为8的$E\rightarrow F$

```
边E(8)	-5	D(∞)	将D点到源点的最短距离由无穷大优化为8-5=3
边E(8)	8	F(∞)	将F点到源点的最短距离由无穷大优化为8+8=16
```

将被优化的点D点F入队

![img](spfa1-6.svg)

此时队列中的点

| B    | D    | F    |
| ---- | ---- | ---- |
| 1    | 3    | 16   |

当前A点到所有点的最短路长度表

| A    | B    | C    | D    | E    | F    |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 0    | 1    | 3    | 3    | 8    | 16   |

#### 第五次优化

将队首的元素B出队，遍历所有以B为起点的边

以B为起点的边有权值为6的$B\rightarrow E$

```
边B(1)	4	E(8)	将E点到源点的最短距离由8优化为1+6=7
```

将被优化的E点入队

![img](spfa1-7.svg)

此时队列中的点

| D    | F    | E    |
| ---- | ---- | ---- |
| 3    | 16   | 7    |

当前A点到所有点的最短路长度表

| A    | B    | C    | D    | E    | F    |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 0    | 1    | 3    | 3    | 7    | 16   |

#### 第六次优化

将队首的元素D出队，遍历所有以D为起点的边

以D为起点的边有权值为4的$D\rightarrow B$

```
边D(3)	6	B(1)	并不能进行优化
```

没有要入队的点

![img](spfa1-8.svg)

此时队列中的点

| F    | E    |
| ---- | ---- |
| 16   | 7    |

当前A点到所有点的最短路长度表

| A    | B    | C    | D    | E    | F    |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 0    | 1    | 3    | 3    | 7    | 16   |

#### 第七次优化

将队首的元素F出队，遍历所有以F为起点的边

以F为起点的边有权值为3的$F\rightarrow C$

```
边F(16)	3	C(3)	并不能进行优化
```

没有要入队的点

![img](spfa1-9.svg)

此时队列中的点

| E    |
| ---- |
| 7    |

当前A点到所有点的最短路长度表

| A    | B    | C    | D    | E    | F    |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 0    | 1    | 3    | 3    | 7    | 16   |

#### 第八次优化

将队首的元素E出队，遍历所有以E为起点的边

以E为起点的边有权值为-5的$E\rightarrow D$与权值为8的$E\rightarrow F$

```
边E(7)	-5	D(3)	将D点到源点的最短距离由无穷大优化为7-5=2
边E(7)	8	F(16)	将F点到源点的最短距离由无穷大优化为7+8=15
```

将被优化的点D点F入队

![img](spfa1-10.svg)

此时队列中的点

| D    | F    |
| ---- | ---- |
| 2    | 15   |

当前A点到所有点的最短路长度表

| A    | B    | C    | D    | E    | F    |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 0    | 1    | 3    | 2    | 7    | 15   |

#### 第九次优化

将队首的元素D出队，遍历所有以D为起点的边

以D为起点的边有权值为4的$D\rightarrow B$

```
边D(2)	4	B(1)	并不能进行优化
```

没有要入队的点

![img](spfa1-11.svg)

此时队列中的点

| F    |
| ---- |
| 15   |

当前A点到所有点的最短路长度表

| A    | B    | C    | D    | E    | F    |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 0    | 1    | 3    | 2    | 7    | 15   |

#### 第十次优化

将队首的元素F出队，遍历所有以F为起点的边

以F为起点的边有权值为3的$F\rightarrow C$

```
边F(15)	3	C(3)	并不能进行优化
```

没有要入队的点



![img](spfa1-12.svg)

此时队列中的点

| 没啦！ |
| ------ |
|        |

当前A点到所有点的最短路长度表

| A    | B    | C    | D    | E    | F    |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 0    | 1    | 3    | 2    | 7    | 15   |

到此为止所有的优化都完成了，虽然比较原生的Bellman-Ford要多了五次优化，但SPFA的每次优化并不需要遍历所有边，只需要遍历以出队点为源点的边即可，这就将SPFA的时间复杂度大大降低，降为了$O(M\times E)$而且通常情况下M不会超过2，这使得SPFA再处理没有负环的情况下的速度往往要优于堆优化的dijkstra，但是不要太寄希望于SPFA，都知道它快，所以有很多题目都会有专门的一组数据来卡SPFA（具体请随便找一个搜索引擎搜索卡SPFA），而且SPFA在有负环时时间复杂度会退化为$O(N\times E)$ 我比较懒，就不模拟负环运行了。

### 代码实现

```c++
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e3;
const int INF = 1e6;
struct Node{
    int v, dis;
};
vector<Node> Adj[MAXN];
int num[MAXN];
bool inq[MAXN];
int d[MAXN];
int n;
bool SPFA(int s){
    fill(d, d + MAXN, INF); //初始化起点到所有点的最短路长度为无穷大
    queue<Node> Q;
    d[s] = 0;   //起点至本身的距离为0
    Q.push(Node{s, 0}); //这里队列中Node.v为当前点 Node.dis为当前点至起点的距离
    inq[s] = true;  //将s标记为已入队
    num[s]++;   //s入队次数加一
    while(!Q.empty()){
        Node f = Q.front();   //获取队首元素
        cout << " 出队点：" << f.v;
        Q.pop();    //出队
        inq[f.v] = false; //将队首对应的点标记为未入队
        for(auto i : Adj[f.v]){ //遍历所有该点的相邻点
            int v = i.v;
            int dis = i.dis;
            if(d[f.v] + i.dis < d[i.v]){    //判断是否可以优化
                d[i.v] = d[f.v] + i.dis;
                if(!inq[i.v]){  //优化并入队
                    Q.push(Node{i.v, d[i.v]});
                    inq[i.v] = true;
                    num[i.v] ++;
                    if(num[v] >= n) //入队次数超过n-1则有负环
                        return false;
                }
            }
        }
    }
    return true;
}
int main()
{
    ios::sync_with_stdio(false);
    cout << "输入顶点数:";
    cin >> n;
    int m;
    cout << "输入边数";
    cin >> m;
    for(int i = 0; i < m; i ++){
        cout << "输入边 (端点1 端点2 权值):" << endl;
        int u, v, dis;
        cin >> u >> v >> dis;
        Adj[u].push_back(Node{v, dis});
        //Adj[v].push_back(Node{u, dis});
    }
    int s;
    cout << "输入起点:";
    cin >> s;
    int e;
    cout << "输入终点:";
    cin >> e;
    if(SPFA(s)){
        cout << "起点到终点最短路长度:" << d[e] << endl;
        for(int i = 0; i < n; i ++){
            cout << i << " : " << d[i] <<endl;
        }
    }else{
        cout << "最短路不存在" << endl;
    }
    system("pause");
    return 0;
}
```



