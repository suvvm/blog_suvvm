---
title: Floyd原理分析
date: 2019-11-16 17:23:17
categories: 
- 算法相关
tags:
- 最短路
mathjax: true
---
## Floyd（弗洛伊德算法）

### Floyd算法原理

Floyd算法是用来解决全源最短路问题的算法，其原理支持便是如果给定的图中存在一个顶点k，使得以k点作为中介点时可以使图中另外两个顶点，顶点i与顶点j之间的最短距离缩短。假设以d\[i\]\[j\]作为当前顶点i与顶点j之间的最短距离，则上述原理可以表示为

```c++
if(d[i][k] + d[k][i] < d[i][j]) {
	d[i][j] = d[i][k] + d[k][i];
}
```

### Floyd过程模拟

以下图为例，进行一次Floyd运行过程的模拟。

![img](floyd1-1.svg)

#### 初始状态

初始将所有点之间的最短距离都记为无穷大，每个点到其本身距离为0，在输入时记录更新路径两端的点的最短距离。

初始最短距离表

|       | A    | B    | C    | D    | E    | F    | G    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **A** | 0    | 2    | ∞    | 1    | ∞    | ∞    | ∞    |
| **B** | ∞    | 0    | ∞    | 3    | 10   | ∞    | ∞    |
| **C** | 4    | ∞    | 0    | ∞    | ∞    | 5    | ∞    |
| **D** | ∞    | ∞    | 2    | 0    | 2    | 8    | 4    |
| **E** | ∞    | ∞    | ∞    | ∞    | 0    | ∞    | 6    |
| **F** | ∞    | ∞    | ∞    | ∞    | ∞    | 0    | ∞    |
| **G** | ∞    | ∞    | ∞    | ∞    | ∞    | 1    | 0    |

#### 第一个k（k为A点）

遍历所有顶点，查看以A点为中介时是否存在任意两点之间的最短距离可以被优化。

可以找到如下可被优化的情况。

```
C->B当前为无穷大 C->A当前为4 A->B当前为2 C->B被A优化为4+2=6
C->D当前为无穷大 C->A当前为4 A->D当前为1 C->D被A优化为4+1=5
```

当前最短距离表

|       | A    | B    | C    | D    | E    | F    | G    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **A** | 0    | 2    | ∞    | 1    | ∞    | ∞    | ∞    |
| **B** | ∞    | 0    | ∞    | 3    | 10   | ∞    | ∞    |
| **C** | 4    | `6`  | 0    | `5`  | ∞    | 5    | ∞    |
| **D** | ∞    | ∞    | 2    | 0    | 2    | 8    | 4    |
| **E** | ∞    | ∞    | ∞    | ∞    | 0    | ∞    | 6    |
| **F** | ∞    | ∞    | ∞    | ∞    | ∞    | 0    | ∞    |
| **G** | ∞    | ∞    | ∞    | ∞    | ∞    | 1    | 0    |

#### 第二个k（k为B点）

遍历所有顶点，查看以B点为中介时是否存在任意两点之间的最短距离可以被优化。

可以找到如下可被优化的情况。

```
A->E当前为无穷大 A->B当前为2 B->E当前为10 A->E被B优化为2+10=12
C->E当前为无穷大 C->B当前为6 B->E当前为10 C->E被B优化为6+10=16
```

当前最短距离表

|       | A    | B    | C    | D    | E    | F    | G    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **A** | 0    | 2    | ∞    | 1    | `12` | ∞    | ∞    |
| **B** | ∞    | 0    | ∞    | 3    | 10   | ∞    | ∞    |
| **C** | 4    | 6    | 0    | 5    | `16` | 5    | ∞    |
| **D** | ∞    | ∞    | 2    | 0    | 2    | 8    | 4    |
| **E** | ∞    | ∞    | ∞    | ∞    | 0    | ∞    | 6    |
| **F** | ∞    | ∞    | ∞    | ∞    | ∞    | 0    | ∞    |
| **G** | ∞    | ∞    | ∞    | ∞    | ∞    | 1    | 0    |

#### 第三个k（k为C点）

遍历所有顶点，查看以C点为中介时是否存在任意两点之间的最短距离可以被优化。

可以找到如下可被优化的情况。

```
D->A当前为无穷大 D->C当前为2 C->A当前为4 D->A被C优化为2+4=6
D->B当前为无穷大 D->C当前为2 C->B当前为6 D->B被C优化为2+6=8
D->F当前为8 D->C当前为2 C->F当前为5 D->F被C优化为2+5=7
```

当前最短距离表

|       | A    | B    | C    | D    | E    | F    | G    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **A** | 0    | 2    | ∞    | 1    | 12   | ∞    | ∞    |
| **B** | ∞    | 0    | ∞    | 3    | 10   | ∞    | ∞    |
| **C** | 4    | 6    | 0    | 5    | 16   | 5    | ∞    |
| **D** | `6`  | `8`  | 2    | 0    | 2    | `7`  | 4    |
| **E** | ∞    | ∞    | ∞    | ∞    | 0    | ∞    | 6    |
| **F** | ∞    | ∞    | ∞    | ∞    | ∞    | 0    | ∞    |
| **G** | ∞    | ∞    | ∞    | ∞    | ∞    | 1    | 0    |

#### 第四个k（k为D点）

遍历所有顶点，查看以D点为中介时是否存在任意两点之间的最短距离可以被优化。

可以找到如下可被优化的情况。

```
A->C当前为无穷大 A->D当前为1 D->C当前为2 A->C被D优化为1+2=3
A->E当前为12 A->D当前为1 D->E当前为2 A->E被D优化为1+2=3
A->F当前为无穷大 A->D当前为1 D->F当前为7 A->F被D优化为1+7=8
A->G当前为无穷大 A->D当前为1 D->G当前为4 A->G被D优化为1+4=5
B->A当前为无穷大 B->D当前为3 D->A当前为6 B->A被D优化为3+6=9
B->C当前为无穷大 B->D当前为3 D->C当前为2 B->C被D优化为3+2=5
B->E当前为10 B->D当前为3 D->E当前为2 B->E被D优化为3+2=5
B->F当前为无穷大 B->D当前为3 D->F当前为7 B->F被D优化为3+7=10
B->G当前为无穷大 B->D当前为3 D->G当前为4 B->G被D优化为3+4=7
C->E当前为16 C->D当前为5 D->E当前为2 C->E被D优化为2+5=7
C->G当前为无穷大 C->D当前为5 D->G当前为4 C->G被D优化为5+4=9
```

当前最短距离表

|       | A    | B    | C    | D    | E    | F    | G    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **A** | 0    | 2    | `3`  | 1    | `3`  | `8`  | `5`  |
| **B** | `9`  | 0    | `5`  | 3    | `5`  | `10` | `7`  |
| **C** | 4    | 6    | 0    | 5    | `7`  | 5    | `9`  |
| **D** | 6    | 8    | 2    | 0    | 2    | 7    | 4    |
| **E** | ∞    | ∞    | ∞    | ∞    | 0    | ∞    | 6    |
| **F** | ∞    | ∞    | ∞    | ∞    | ∞    | 0    | ∞    |
| **G** | ∞    | ∞    | ∞    | ∞    | ∞    | 1    | 0    |

#### 第五个k（k为E点）

遍历所有顶点，查看以E点为中介时是否存在任意两点之间的最短距离可以被优化。

找不到可被优化的点。

当前最短距离表

|       | A    | B    | C    | D    | E    | F    | G    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **A** | 0    | 2    | 3    | 1    | 3    | 8    | 5    |
| **B** | 9    | 0    | 5    | 3    | 5    | 10   | 7    |
| **C** | 4    | 6    | 0    | 5    | 7    | 5    | 9    |
| **D** | 6    | 8    | 2    | 0    | 2    | 7    | 4    |
| **E** | ∞    | ∞    | ∞    | ∞    | 0    | ∞    | 6    |
| **F** | ∞    | ∞    | ∞    | ∞    | ∞    | 0    | ∞    |
| **G** | ∞    | ∞    | ∞    | ∞    | ∞    | 1    | 0    |

#### 第六个k（k为F点）

遍历所有顶点，查看以F点为中介时是否存在任意两点之间的最短距离可以被优化。

找不到可被优化的点。

当前最短距离表

|       | A    | B    | C    | D    | E    | F    | G    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **A** | 0    | 2    | 3    | 1    | 3    | 8    | 5    |
| **B** | 9    | 0    | 5    | 3    | 5    | 10   | 7    |
| **C** | 4    | 6    | 0    | 5    | 7    | 5    | 9    |
| **D** | 6    | 8    | 2    | 0    | 2    | 7    | 4    |
| **E** | ∞    | ∞    | ∞    | ∞    | 0    | ∞    | 6    |
| **F** | ∞    | ∞    | ∞    | ∞    | ∞    | 0    | ∞    |
| **G** | ∞    | ∞    | ∞    | ∞    | ∞    | 1    | 0    |

#### 第七个k（k为G点）

遍历所有顶点，查看以G点为中介时是否存在任意两点之间的最短距离可以被优化。

可以找到如下可被优化的情况。

```
A->F当前为8 A->G当前为5 G->F当前为1 A->F被G优化为5+1=6
B->F当前为10 B->G当前为7 G->F当前为1 B->F被G优化为7+1=8
D->F当前为7 D->G当前为4 G->F当前为1 D->F被G优化为4+1=5
E->F当前为无穷大 E->G当前为6 G->F当前为1 E->F被G优化为6+1=7
```

当前最短距离表

|       | A    | B    | C    | D    | E    | F    | G    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **A** | 0    | 2    | 3    | 1    | 3    | `6`  | 5    |
| **B** | 9    | 0    | 5    | 3    | 5    | `8`  | 7    |
| **C** | 4    | 6    | 0    | 5    | 7    | 5    | 9    |
| **D** | 6    | 8    | 2    | 0    | 2    | `5`  | 4    |
| **E** | ∞    | ∞    | ∞    | ∞    | 0    | `7`  | 6    |
| **F** | ∞    | ∞    | ∞    | ∞    | ∞    | 0    | ∞    |
| **G** | ∞    | ∞    | ∞    | ∞    | ∞    | 1    | 0    |

#### 最终结果

当前最短距离表

|       | A    | B    | C    | D    | E    | F    | G    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **A** | 0    | 2    | 3    | 1    | 3    | 6    | 5    |
| **B** | 9    | 0    | 5    | 3    | 5    | 8    | 7    |
| **C** | 4    | 6    | 0    | 5    | 7    | 5    | 9    |
| **D** | 6    | 8    | 2    | 0    | 2    | 5    | 4    |
| **E** | ∞    | ∞    | ∞    | ∞    | 0    | 7    | 6    |
| **F** | ∞    | ∞    | ∞    | ∞    | ∞    | 0    | ∞    |
| **G** | ∞    | ∞    | ∞    | ∞    | ∞    | 1    | 0    |

### 代码实现

```c++
#include <bits/stdc++.h>
using namespace std;
const int INF = 1e6;
const int MAXN = 1e3;
int n;
int dis[MAXN][MAXN];
void Floyd(){
    for(int k = 0; k < n; k ++){    //存在顶点k可以使得顶点i到顶点j的最小距离缩短
        for(int i = 0; i < n; i ++){
            for(int j = 0; j < n; j ++){
                if(dis[i][k] != INF && dis[k][j] != INF && dis[i][k] + dis[k][j] < dis[i][j]){
                    dis[i][j] = dis[i][k] + dis[k][j];
                   // printf("%c优化%c->%c:%7d\n",'A' + k ,'A'+i, 'A'+j,dis[i][j]);
                }
            }
        }
        /* 输出每次优化的数据
        for(int i = 0; i < n; i ++){
            for( int j = 0; j < n; j ++){
                printf("%c->%c:%7d ", 'A'+i, 'A'+j,dis[i][j]);
                // cout << dis[i][j] << " ";
            }
            cout << endl;
        }
        cout << endl;
        */
    }
    /*
    for(int i = 0; i < n; i ++){    // 错误写法
        for(int j = 0; j < n; j ++){
            for(int k = 0; k < n; k ++){
                if(dis[i][k] != INF && dis[k][j] != INF && dis[i][k] + dis[k][j] < dis[i][j]){
                    dis[i][j] = dis[i][k] + dis[k][j];
                }
            }
        }
    }*/

}
int main()
{
    fill(dis[0], dis[0] + MAXN * MAXN, INF);
    ios::sync_with_stdio(false);
    cout << "输入顶点数:";
    cin >> n;
    int m;
    cout << "输入边数";
    cin >> m;
    for(int i = 0; i < m; i ++){
        dis[i][i] = 0;
        cout << "输入边 (端点1 端点2 权值):" << endl;
        int u, v, w;
        cin >> u >> v >> w;
        dis[u][v] = w;
        //dis[v][u] = dis;
    }
    for(int i = m; i < n; i ++){
        dis[i][i] = 0;
    }
    cout << "初始状态：" << endl;
    for(int i = 0; i < n; i ++){
        for( int j = 0; j < n; j ++){
            printf("%c->%c:%7d ", 'A'+i, 'A'+j,dis[i][j]);
            // cout << dis[i][j] << " ";
        }
        cout << endl;
    }
    cout << endl << endl;

    Floyd();
    cout << "最终状态：" << endl;
    for(int i = 0; i < n; i ++){
        for( int j = 0; j < n; j ++){
            printf("%c->%c:%7d ", 'A'+i, 'A'+j,dis[i][j]);
            // cout << dis[i][j] << " ";
        }
        cout << endl;
    }

    return 0;
}
```

### 常见错误

对于Floyd算法来说，最外层循环的k不能放到内层，如果将k放到内层会导致最终结果出错，这是因为如果先对被优化的点进行遍历的话，当其遍历过去后相当于已经固定之后再也无法优化。

例如，如果当前有一条路径i->u->v->j若u > i 在遍历到u时出现了点k可以将u->v的距离缩短，但这时却无法重新对i->j进行优化，这就导致了错误。

### 错误模拟

以下图为例，进行一次Floyd错误运行的模拟。

![img](floyd1-1.svg)

#### 初始状态

初始将所有点之间的最短距离都记为无穷大，每个点到其本身距离为0，在输入时记录更新路径两端的点的最短距离。

初始最短距离表

|       | A    | B    | C    | D    | E    | F    | G    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **A** | 0    | 2    | ∞    | 1    | ∞    | ∞    | ∞    |
| **B** | ∞    | 0    | ∞    | 3    | 10   | ∞    | ∞    |
| **C** | 4    | ∞    | 0    | ∞    | ∞    | 5    | ∞    |
| **D** | ∞    | ∞    | 2    | 0    | 2    | 8    | 4    |
| **E** | ∞    | ∞    | ∞    | ∞    | 0    | ∞    | 6    |
| **F** | ∞    | ∞    | ∞    | ∞    | ∞    | 0    | ∞    |
| **G** | ∞    | ∞    | ∞    | ∞    | ∞    | 1    | 0    |

#### 第一个i（i为A点）

遍历所有顶点，查看以A点为起点时是否存在A到任意其他一点之间的最短距离可以被另一点优化。

可以找到如下可被优化的情况。

```
A->C当前为无穷大 A->D当前为1 D->C当前为2 A->C被D优化为1+2=3
A->E当前为无穷大 A->B当前为2 B->E当前为10 A->E被B优化为2+10=12
A->E当前为12 A->D当前为1 D->E当前为2 A->E被D优化为1+2=3
A->F当前为无穷大 A->C当前为3 C->F当前为5 A->F被C优化为3+5=8
A->G当前为无穷大 A->D当前为1 D->G当前为4 A->G被C优化为1+4=5
```

当前最短距离表

|       | A    | B    | C    | D    | E    | F    | G    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **A** | 0    | 2    | `3`  | 1    | `3`  | `8`  | `5`  |
| **B** | ∞    | 0    | ∞    | 3    | 10   | ∞    | ∞    |
| **C** | 4    | ∞    | 0    | ∞    | ∞    | 5    | ∞    |
| **D** | ∞    | ∞    | 2    | 0    | 2    | 8    | 4    |
| **E** | ∞    | ∞    | ∞    | ∞    | 0    | ∞    | 6    |
| **F** | ∞    | ∞    | ∞    | ∞    | ∞    | 0    | ∞    |
| **G** | ∞    | ∞    | ∞    | ∞    | ∞    | 1    | 0    |

#### 第二个i（i为B点）

遍历所有顶点，查看以B点为起点时是否存在B到任意其他一点之间的最短距离可以被另一点优化。

可以找到如下可被优化的情况。

```
B->C当前为无穷大 B->D当前为3 D->C当前为2 B->C被D优化为3+2=5
B->E当前为10 B->D当前为3 D->E当前为2 B->E被D优化为3+2=5
B->F当前为无穷大 B->C当前为5 C->F当前为5 B->F被C优化为5+5=10
B->G当前为无穷大 B->D当前为3 D->G当前为4 B->G被D优化为3+4=7
```

当前最短距离表

|       | A    | B    | C    | D    | E    | F    | G    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **A** | 0    | 2    | 3    | 1    | 3    | 8    | 5    |
| **B** | ∞    | 0    | `5`  | 3    | `5`  | `10` | `7`  |
| **C** | 4    | ∞    | 0    | ∞    | ∞    | 5    | ∞    |
| **D** | ∞    | ∞    | 2    | 0    | 2    | 8    | 4    |
| **E** | ∞    | ∞    | ∞    | ∞    | 0    | ∞    | 6    |
| **F** | ∞    | ∞    | ∞    | ∞    | ∞    | 0    | ∞    |
| **G** | ∞    | ∞    | ∞    | ∞    | ∞    | 1    | 0    |

#### 第三个i（i为C点）

遍历所有顶点，查看以C点为起点时是否存在C到任意其他一点之间的最短距离可以被另一点优化。

可以找到如下可被优化的情况。

```
C->B当前为无穷大 C->A当前为4 A->B当前为2 C->B被A优化为4+2=6
C->D当前为无穷大 C->A当前为4 A->D当前为1 C->D被A优化为4+1=5
C->E当前为无穷大 C->A当前为4 A->E当前为3 C->E被A优化为4+3=7
C->G当前为无穷大 C->A当前为4 A->G当前为5 C->G被A优化为4+5=9
```

当前最短距离表

|       | A    | B    | C    | D    | E    | F    | G    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **A** | 0    | 2    | 3    | 1    | 3    | 8    | 5    |
| **B** | ∞    | 0    | 5    | 3    | 5    | 10   | 7    |
| **C** | 4    | `6`  | 0    | `5`  | `7`  | 5    | `9`  |
| **D** | ∞    | ∞    | 2    | 0    | 2    | 8    | 4    |
| **E** | ∞    | ∞    | ∞    | ∞    | 0    | ∞    | 6    |
| **F** | ∞    | ∞    | ∞    | ∞    | ∞    | 0    | ∞    |
| **G** | ∞    | ∞    | ∞    | ∞    | ∞    | 1    | 0    |

#### 第四个i（i为D点）

遍历所有顶点，查看以D点为起点时是否存在D到任意其他一点之间的最短距离可以被另一点优化。

可以找到如下可被优化的情况。

```
D->A当前为无穷大 D->C当前为2 C->A当前为4 D->A被C优化为2+4=6
D->B当前为无穷大 D->A当前为6 A->B当前为2 D->B被A优化为6+2=8
D->F当前为8 D->C当前为2 C->F当前为5 D->F被C优化为2+5=7
D->F当前为7 D->G当前为4 G->F当前为1 D->F被G优化为4+1=5
```

当前最短距离表

|       | A    | B    | C    | D    | E    | F    | G    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **A** | 0    | 2    | 3    | 1    | 3    | 8    | 5    |
| **B** | ∞    | 0    | 5    | 3    | 5    | 10   | 7    |
| **C** | 4    | 6    | 0    | 5    | 7    | 5    | 9    |
| **D** | `6`  | `8`  | 2    | 0    | 2    | `5`  | 4    |
| **E** | ∞    | ∞    | ∞    | ∞    | 0    | ∞    | 6    |
| **F** | ∞    | ∞    | ∞    | ∞    | ∞    | 0    | ∞    |
| **G** | ∞    | ∞    | ∞    | ∞    | ∞    | 1    | 0    |

#### 第五个i（i为E点）

遍历所有顶点，查看以E点为起点时是否存在E到任意其他一点之间的最短距离可以被另一点优化。

可以找到如下可被优化的情况。

```
E->F当前为无穷大 E->G当前为6 G->F当前为1 E->F被G优化为6+1=7
```

当前最短距离表

|       | A    | B    | C    | D    | E    | F    | G    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **A** | 0    | 2    | 3    | 1    | 3    | 8    | 5    |
| **B** | ∞    | 0    | 5    | 3    | 5    | 10   | 7    |
| **C** | 4    | 6    | 0    | 5    | 7    | 5    | 9    |
| **D** | 6    | 8    | 2    | 0    | 2    | 5    | 4    |
| **E** | ∞    | ∞    | ∞    | ∞    | 0    | `7`  | 6    |
| **F** | ∞    | ∞    | ∞    | ∞    | ∞    | 0    | ∞    |
| **G** | ∞    | ∞    | ∞    | ∞    | ∞    | 1    | 0    |

#### 第六个i（i为F点）

遍历所有顶点，查看以F点为起点时是否存在F到任意其他一点之间的最短距离可以被另一点优化。

没有可优化的情况。

当前最短距离表

|       | A    | B    | C    | D    | E    | F    | G    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **A** | 0    | 2    | 3    | 1    | 3    | 8    | 5    |
| **B** | ∞    | 0    | 5    | 3    | 5    | 10   | 7    |
| **C** | 4    | 6    | 0    | 5    | 7    | 5    | 9    |
| **D** | 6    | 8    | 2    | 0    | 2    | 5    | 4    |
| **E** | ∞    | ∞    | ∞    | ∞    | 0    | 7    | 6    |
| **F** | ∞    | ∞    | ∞    | ∞    | ∞    | 0    | ∞    |
| **G** | ∞    | ∞    | ∞    | ∞    | ∞    | 1    | 0    |

#### 第七个i（i为G点）

遍历所有顶点，查看以G点为起点时是否存在G到任意其他一点之间的最短距离可以被另一点优化。

没有可优化的情况。

当前最短距离表

|       | A    | B    | C    | D    | E    | F    | G    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **A** | 0    | 2    | 3    | 1    | 3    | 8    | 5    |
| **B** | ∞    | 0    | 5    | 3    | 5    | 10   | 7    |
| **C** | 4    | 6    | 0    | 5    | 7    | 5    | 9    |
| **D** | 6    | 8    | 2    | 0    | 2    | 5    | 4    |
| **E** | ∞    | ∞    | ∞    | ∞    | 0    | 7    | 6    |
| **F** | ∞    | ∞    | ∞    | ∞    | ∞    | 0    | ∞    |
| **G** | ∞    | ∞    | ∞    | ∞    | ∞    | 1    | 0    |

#### 错误结果

当前最短距离表

|       | A    | B    | C    | D    | E    | F    | G    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **A** | 0    | 2    | 3    | 1    | 3    | 8    | 5    |
| **B** | ∞    | 0    | 5    | 3    | 5    | 10   | 7    |
| **C** | 4    | 6    | 0    | 5    | 7    | 5    | 9    |
| **D** | 6    | 8    | 2    | 0    | 2    | 5    | 4    |
| **E** | ∞    | ∞    | ∞    | ∞    | 0    | 7    | 6    |
| **F** | ∞    | ∞    | ∞    | ∞    | ∞    | 0    | ∞    |
| **G** | ∞    | ∞    | ∞    | ∞    | ∞    | 1    | 0    |

明显与上方正确答案存在很大差异

所以对中介点k的遍历一定要放在最外层。