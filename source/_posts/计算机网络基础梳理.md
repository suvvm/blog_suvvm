---
title: 计算机网络基础梳理
date: 2019-12-23 20:10:41
categories: 
- 理论归纳
tags:
- 计算机网络
mathjax: true
---

# 计算机网络

[TOC]

## 概述

### 互联网发展历史

- 1969年第一个网络ARPANET
- 1983年Internet因特网诞生（TCP/IP成为ARPANET标准协议）
- 1994年，我国接入互联网

#### 互联网基础结构发展的三个阶段

- 第一阶段：ARPANET向互联网发展
- 第二阶段：三级结构互联网
- 第三阶段：多层次ISP结构的互联网

### 互联网的组成

- 核心部分：大量网络与链接这些网络的路由器，为边缘部分提供服务
- 边缘部分：所有链接在互联网上的主机，由用户直接组成

#### 核心部分

- 核心技术：

  分组交换：使用存储转发技术，把一个报文划分为几个分组后再进行发送

- 核心设备：路由器

### 性能指标

- 速率（数据率/比特率）

  数据传输的速率 比特每秒(bit/s)

- 带宽

  单位时间内网络中某信道能通过的最高数据率 比特每秒(bit/s)

- 吞吐量

  单位时间内通过某个网络的实际数据量 比特每秒(bit/s)

- **时延**

  数据从网络的一段传到另一端所需的时间

  - **发送时延**（传输时延）

    主机或路由器发送数据帧所需要的时间
    $$
    发送时延=\frac{数据帧长度(bit)}{发送速率(bit/s)}
    $$

  - **传播时延**

    电磁波在信道中传播一定距离需要花费的时间
    $$
    传播时延 = \frac{信道长度(m)}{电磁波再信道上的传播速率(m/s)光纤:2.0\times10^5km/s}
    $$

  - 处理时延

    主机或路由器收到分组后的处理时间

  - 排队时延

    进入路由器后再输入队列中排队的时延

- 时延带宽积

  线路上的最大bit数
  $$
  时延带宽积 = 传播时延 \times 带宽
  $$

- 往返时间RTT
  $$
  有效数据率 =\frac{数据长度}{发送时延+RTT}
  $$

- 利用率

  某信道有百分之几的时间是被利用的$D（当前时延）=\frac{D_0（网络空闲时延）}{1-U（利用率）}$

### 体系结构

- OSI体系结构

  7. 应用层

  6. 表示层

  5. 会话层

  4. 运输层

  3. 网络层

  2. 数据链路层

  1. 物理层

- TCP/IP体系结构

  - 应用层（应用层协议）
  - 运输层
  - 网际层IP
  - 网络接口层

- 五层协议体系结构

  5. 应用层

  4. 运输层

  3. 网络层

  2. 数据链路层

  1. 物理层

对等层次之间传送的数据单位称为，OSI协议数据单元PDU

#### 应用层

通过应用进程间交互完成特定网络应用

应用层协议：应用进层间的通信和交互规则如DNS HTTP

 电子邮件SMTP 

应用层交互数据单元 **报文**

#### 运输层

向两台主机中的进程直接的通信提供数据传输服务

运输层协议

- 传输控制协议TCP 数据传输单位 **报文段**
- 用户数据报协议UDP 数据传输单位 **用户数据报**

#### 网络层

为分组交换网上不同主机提供通信服务，将运输层报文段或用户数据报封装为分组（**IP数据报**）或包进行传送

网络层协议

IP协议 

#### 数据链路层

使用专门的链路层协议在链路上传输数据 将网络层交下来的IP数据报**封装成帧**。

#### 物理层

物理层要考虑代表0 1的电压 接收方如何识别发送方的比特 确定链接电缆的插头的引脚数。

物理层数据传输单位是**比特**

## 物理层

### 信号调制

调制可分为两大类

- 基带调制

  仅对基带信号（来自信源的信号）的波形进行变化，变换后仍为基带信号的。

- 带通调制

  使用载波进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，变换后的信号被称为带通信号

  

  基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。为了解决这一问题，就必须对基带信号进行带通调制

  基本带通调制方法

  - 调幅（AM）

    载波振幅随基带数字信号而变化 0 1分别代表无载波输出与有载波输出

  - 调频（FM）

    载波频率随基带数字信号而变化 0 1分别对应频率f1与f2

  - 调相（PM）

    载波初始相位随基带数字信号而变化 0 1分别对应相位0度与相位180度

    正交振幅调制 （调幅+调相）

常用编码方式

- 不归零制
- 归零制
- 曼彻斯特编码
- 差分曼彻斯特编码

而曼彻斯特编码和差分曼彻斯特编码具有自同步能力

![img](计算机网络基础梳理\常用编码方式.png)

### 码元

在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形。

在数字通信中常用时间间隔相同的符号来表示一个二进制数字，这样的时间间隔内的信号称为二进制码元，这个间隔被称为码元长度

比如在一个二进制码元中，由两个电平信号承载比特数据，也就是一个电平信号表示1，一个表示0。在一个四进制码元中，由四个电平信号承载比特数据，也就是一个电平信号表示两位11,10,01,00

![img](计算机网络基础梳理\码元.JPG)

码元传输的速率越高，或信号传输的距离越远，或传输媒体质量越差，在信道的输出端的波形的失真就越严重。

**信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高**

香农公式$C=Wlog_2(1+\frac SN)$

**W** 为信道的带宽（以Hz为单位）；

 **S** 为信道内所传信号的平均功率；

 **N** 为信道内部的高斯噪声功率。

**码元离散值**

码元离散值为N，该码元为N进制码元，可以携带$log_2N$bit数据

### 信道复用的技术

#### 频分复用

将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带

频分复用的所有用户在同样的时间占用不同的带宽资源（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）

![img](计算机网络基础梳理\频分复用.JPG)

#### 时分复用

时分复用则是将时间划分为一段段等长的时分复用帧（TDM 帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。
每一个用户所占用的时隙是周期性地出现（其周期就是 TDM  帧的长度）。

**时分复用的所有用户是在不同的时间占用同样的频带宽度。**

![img](计算机网络基础梳理\时分复用.JPG)

时分复用可能会造成线路资源的浪费

![img](计算机网络基础梳理\时分复用_浪费.JPG)

####  波分复用

光的频分复用，一根光纤同时传送多个光载波信号

#### 码分复用CDM

常用的名词是码分多址 CDMA 

用code来区分用户，每个用户分配一个唯一的code码型（码片序列），通长是64位或128位

发送数据时，用code对原始信号的码元进行编码，生成发送信号。

##### 码片序列

每一个比特时间划分为 m 个短的间隔，称为码片 (chip)。
每个站被指派一个唯一的 m bit 码片序列。

- 如发送比特 1，则发送自己的 m bit 码片序列。

- 如发送比特 0，则发送该码片序列的二进制反码。 

例如，S 站的 8 bit 码片序列是 00011011。

- 发送比特 1 时，就发送序列 00011011，

- 发送比特 0 时，就发送序列 11100100。

每个站分配的码片序列不仅必须各不相同，并且还必须互相正交 (orthogonal)。

S · T = 0

在实用的系统中是使用伪随机码序列

##### 例题

**共有4个站进行码分多址通信。4个站的码片序列为**

A：（－1－1－1＋1＋1－1＋1＋1） B：（－1－1＋1－1＋1＋1＋1－1）

C：（－1＋1－1＋1＋1＋1－1－1） D：（－1＋1－1－1－1－1＋1－1）

现收到这样的码片序列S：（－1＋1－3＋1－1－3＋1＋1）。问哪个站发送数据了？发送数据的站发送的是0还是1？
$$
(-1 +1 -3 +1 -1 -3 +1 +1) \times(-1 -1 -1 +1 +1 -1 +1 +1) = (+1 -1 +3 +1 -1 +3 +1 +1)/8 = 1 A:1\\
(-1 +1 -3 +1 -1 -3 +1 +1) \times(-1 -1 +1 -1 +1 -1 +1 -1) = (+1 -1 -3 -1 -1 -3 +1 -1)/8 = -1 B:0\\
(-1 +1 -3 +1 -1 -3 +1 +1) \times(-1 +1 -1 +1 +1 +1 -1 -1) = (+1 +1 +3 +1 -1 -3 -1 -1)/8 = 0 C:不发\\
(-1 +1 -3 +1 -1 -3 +1 +1) \times(-1 +1 -1 -1 -1 -1 +1 -1) = (+1 +1 +3 -1 +1 +3 +1 -1)/8 = 1 D:1
$$

## 数据链路层

### 数据链路理解

- 链路：从一个结点到相邻结点的物理线路（中间无交换节点）
- 数据链路：包括链路与一些必要的通信协议来控制数据传输（使用网络适配器实现）
- 帧 （点对点信道的数据链路层协议单元）由网络层交下来的数据（ip数据报）构成

### 基本任务

- 封装成帧
- 透明传输
- 差错检验

#### 封装成帧

在网络层IP数据报的前后分别添加首部与尾部

包括帧首部 帧数据 帧尾部

首部与尾部用于进行帧定界含有帧定界符

- SOH开始定界符
- EOT结束定界符

数据部分最大上限称为**最大传送单元（MTU）1500字节**

#### 透明传输

无论什么样的比特流组合的数据都能按照原样没有差错地通过这个数据链路层，所以为了避免数据中有数据与EOT重复被视为帧提前结束，要使用**字节填充**来处理

字节填充：在SOH或EOT之前添加转译字符ESC(1B)

#### 差错检测

使用循环冗余检测CRC

在要传输时会给出一根除数P 的k位数据后添加n（比P小一位）位冗余码

计算方法

现在K位要发送的数据后加n位0，将得到的k+n位数据作为被除数除以P，得到的n位余数就是冗余码（帧检验序列FCS）

接收端将收到的数据除以P检测得到的余数是否为0 

- 如果为0证明没有出错则接受

- 若不为0证明出错（无法确定错在哪里，直接丢弃）

##### 例题

要发送的数据为1101011011。采用CRC的生成多项式是P(X)= X4+X+1。试求应添加在数据后面的余数。数据在传输过程中最后一个1变成了0，问接收端能否发现？若数据在传输过程中最后两个1都变成了0，问接收端能否发现？采用CRC检验后，数据链路层的传输是否就变成了可靠的传输？
$$
P(X) = X^4 + X + 1 \\
P =10011(n=4)\\
余数：\frac{11010110110000}{10011}=1100001010 \cdots\cdots 1110\\
最后1变0：\frac{11010110101110}{10011}= 1100001011\cdots\cdots 1011可以发现\\
最后两个1变0：\frac{11010110001110}{10011}=1100000111 \cdots\cdots 10111可以发现\\可以发现
可靠传输：错了就直接仍
$$

### 协议三要素

- 语法
- 语义 
- 同步

### 点对点传输协议

![img](计算机网络基础梳理\PPP格式.JPG)



FCS检测范围：A + C + 协议 + 数据部分

PPP协议场景：

- 拨号上网
- 广域网两个相邻路由器之间

满足的需求

- 简单

  只进行CRC检验，正确就收下否则就丢弃，其他什么都不管

- 封装成帧 PPP使用特数字符作为帧定界符 7E

- 透明传输

  同步：零比特填充

  有5个连续1就填入一个0（接收时删除）

  异步：字节填充

  采取有效措施解决数据中与帧定界符7E重合的情况

  将0x7D视为转义字符 

  数据中遇到0x7E就将其转为 0x7D 0x5E

  数据中遇到0x7D将其转译为 0x7D 0x5D

  遇到小于0x20的字符将其转译为 0x7D (0x20 + 原字符)

  例题

  一个PPP帧的数据部分（用十六进制写出）是7D 5E FE 27 7D 5D 7D 5D 65 7D 5E。试问真正的数据是什么（用十六进制写出）？

  字节填充规定0x7D为转义字符，将0x7E变为（0x&D，0x5E）将0x7D变为（0x7D，0x5D）
  $$
  {\underbrace{7D\ \ 5E}\\ \ \ \ \ 7E\ \ }\ \  {FE\\FE}\ \ {27\\27}\ \ {\underbrace{7D\ \ 5D}\\ \ \ \ \ 7D}\ \ {\underbrace{7D\ \ 5D}\\ \ \ \ 7D}\ \ {65\\65}\ \ {\underbrace{7D\ \ 5E}\\ \ \ \ 7E}\\
  $$

- 多种网络层协议 支持多种网络层协议

- 多种链路层协议 支持在多种链路上运行如串行线路 并行链路 同步链路 异步链路等等

- 差错检测

  CRC出错就丢弃

- 检测链接状态

  自动检测链路是否正常工作

- 最大传输单元MTU 分片由高层协议处理，PPP收到超出长度的帧就丢弃

- 网络层地址协商

- 数据压缩协商

异步传输按字符传输

同步传输按帧传输 

### 载波侦听多路访问/冲突检测协议（CSMA/CD）

局域网处理冲突

- 多点接入 多个主机随机接入共享一根总线
- 载波监听 每个主机发送数据前检测是否有其他主机在发送数据避免冲突
- 碰撞检测 边发送数据便检测有无碰撞

#### CSMA/CD过程

![img](计算机网络基础梳理\CSMACD过程.JPG)



##### 随机数r选取方法

- 第一次重传

  r从{0, 1}中随机选取一个后 等待r个争用期

- 第二次重传

  r从{0, 1, 2}中随机选取一个后等待r个争用期

- 第三次重传

  r从{0, 1, 2, 3}中随机选取一个后等待r个争用期

- ……

- 第十次重传

  r从{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}中随机选取一个后等待r个争用期

- 第十一次重传

  r=10 等待r个争用期

- 第十二次重传

  r=10 等待r个争用期

- ……

- 第十六次重传

- r = 10 若还未发送成功，放弃重传

#### 原理

- 先听后发
- 边听边发
- 冲突停发
- 随机延迟后重发

#### 争用期

10Mbit/s 争用期（发送一个64字节的最短帧 512比特时间）长度为51.2us

100Mbit/s 争用期 5.12us

### 最短帧

64字节正好填充2.5km的线路一个来回

最小帧间隔：9.6us （96比特时间）

### 以太网MAC

MAC地址：6字节 48位 硬件地址（物理地址）网卡

MAC有6字节 2字节两种

IEEE提供前24位 厂商分配后24位

第一字节最低第2位为G/L位为1时为全球管理（全球不同）为0时为本地管理

#### 帧种类 

- 单播 MAC地址与本站硬件地址相同
- 广播 全1
- 多播 发给本局域网一部分地址

#### MAC帧格式

![img](计算机网络基础梳理\MAC帧.JPG)

### 以太网的物理层标准

| 标准       | 颁布时间                 | 数据率    | 拓扑 | 媒体                                                | 半双工 | 全双工 |
| ---------- | ------------------------ | --------- | ---- | --------------------------------------------------- | ------ | ------ |
| 10BASE5    | DIX-1980<br/> 802.3-1983 | 10 Mb/s   | 总线 | 一根 50 W 同轴电缆 (粗缆以太网) (10 mm 直径)        | 500    | 不使用 |
| 10BASE2    | 802.3a-1985              | 10  Mb/s  | 总线 | 一根 50 W RG 58 同轴电缆   (细缆以太网) (5 mm 直径) | 185    | 不使用 |
| 10BASE-T   | 802.3i-1990              | 10  Mb/s  | 星形 | 两对100 W 的3类或更好的UTP 电缆                     | 100    | 100    |
| 100BASE-TX | 802.3u-1995              | 100  Mb/s | 星形 | 两对100 W 的5类UTP 电缆                             | 100    | 100    |
| 100BASE-FX | 802.3u-1995              | 100  Mb/s | 星形 | 两根光纤                                            | 412    | 2000   |
| 100BASE-T4 | 802.3u-1995              | 100  Mb/s | 星形 | 4对100 W 的3 或更好的UTP电缆                        | 100    | 不使用 |

10BASE－T的主要技术特性：
(1)数据传输速率 10Mbps基带传输
(2)每段双绞线最大长度 100m (HUB与主机间及两个HUB之间)
(3)一条通路允许连接HUB数4个，最多5段传输介质
(4)拓扑结构星形
(5)访问控制方式 CSMA/CD
(6)帧长64~1518个字节
(7)最大传输距离 500m
(8)每个HUB可连接的主机 96个

- 100BASE-TX：1对接收，1对发送
- 1000BASE-T：2对接收，2对发送。
- 100BASE-T4：1对收，1对发，2对动态切换。

### MAC与IP的区别

- 地址性质不同 MAC地址是物理地址 IP地址是逻辑地址
- 每个硬件出厂时候的MAC地址是固定的IP地址可变
- 长度不同 IP地址为32位 MAC地址为48位
- IP地址应用于网络层和以上各层 MAC地址应用于数据链路层和物理层

### 集线器与交换机的不同

#### 集线器

碰撞域：如果一个网络中的主机通讯会发生冲突，这个网络就是一个碰撞域

- 逻辑总线 
  - 集线器使用电子器件模拟实际电缆线的工作
  - 使用集线器的以太网在逻辑上仍是一个总线网
  - 使用的还是CSMA/CD协议
- 多接口转发器： 有多个接口
- 转发时不进行碰撞检测
  - 集线器工作在物理层，每个接口仅仅转发比特，不进行碰撞检测

#### 交换机（交换式集线器）

- 消除了冲突域
- 接口全双工
- 不使用CSMA/CD协议
- 比集线器安全
- 接口可以工作在不同频率
- 广播帧将转发到所有接口（广播域）

交换机的自学习算法

查交换表，交换表里有对应目的MAC地址就之间转发

没有则发生广播帧询问

例题

交换机有6个接口，分别接到5台主机和一个路由器

![img](计算机网络基础梳理\交换机查表例题.JPG)



在下面动作一栏中先后发送了4个帧，假设开始时以太网交换表是空的，补充下表

| 动作       | 交换表的状态      | 向哪些接口转发帧 | 说明                                          |
| ---------- | ----------------- | ---------------- | --------------------------------------------- |
| A发送帧给D | MAC地址A    接口1 | 广播             | 交换表中没有D的对应接口，广播并记录A的接口    |
| D发送帧给A | MAC地址D    接口4 | 接口1            | 交换表中有A的对应接口，向A发送帧并记录D的接口 |
| E发送帧给A | MAC地址E    接口5 | 接口1            | 交换表中有A的对应接口，向A发送帧并记录E的接口 |
| A发送帧给E | 没有变动          | 接口5            | 交换表中有A和E对应接口，向E发送帧             |

## 网络层

- IP编制 ： 同一全球互联网的逻辑地址
- 地址转换： IP地址$\rightarrow$ 数据链路层MAC地址
- 路由协议：任意两个IP之间的路线规划
- 分组转发： IP协议实现分组交换

### IP编址

IP 地址就是给每个连接在互联网上的主机（或路由器）分配一个在全世界范围是唯一的 32 位的标识符。

IP 地址现在由互联网名字和数字分配机构ICANN (Internet Corporation for Assigned Names and Numbers)进行分配

#### IP编址的三个阶段

- 分类IP
- 子网划分
- 构造超网

#### 分类IP

这是最基本的编址方法，在 1981 年就通过了相应的标准协议

A类地址 1.0.0.0 ~ 126.255.255.255 主机数  256 * 256 * 256 - 2 首位为0
A类保留地址 127 首位为0
B类地址 128.0.0.0 ~ 191.255.255.255	256 * 256 - 2	首位为10
C类地址 192.0.0.0 ~ 223.255.255.255	256 - 2 首位为110
D类地址 224.0.0.0 ~ 239.255.255.255 多播地址 首位为1110
E类地址 240.0.0.0 ~ 255.255.255.255 保留地址 首位为1111

例题

试辨认以下IP地址的网络类别。

 （1）128.36.199.3   （2）21.12.240.17  （3）183.194.76.253   （4）192.12.69.248  （5）89.3.0.1     （6）200.3.6.2

1. 128.36.199.3	B类地址
2. 21.12.240.17    A类地址
3. 183.194.76.253    B类地址
4. 192.12.69.248   C类地址
5. 89.2.0.1             A类地址
6. 200.3.6.2          C类地址

#### 子网划分

为了解决IP地址不够用的情况，对最基本的编址方法的改进，在 IP 地址中又增加了一个“子网号字段”，使两级的 IP 地址变成为三级的 IP 地址。

![img](计算机网络基础梳理\子网划分_1.JPG)

为了识别IP中的子网部分使用了子网掩码

子网掩码为1表示对应位为子网

子网掩码为0表示对应位为主机号

![img](计算机网络基础梳理\子网划分_2.JPG)

划分子网的基本思路（子网划分中子网号全0全1不能使用）

- 根据子网中最大的主机数量确定子网所需主机号位数
- 根据主机号位数与给定IP地址确定子网号位数
- 进行子网划分后选择一个可用地址分配给对应子网
- 若当前划分子网个数不够用则需要选择一个可用子网继续划分
- 根据剩余子网中最大的主机数量确定子网所需主机号位数
- 根据主机号位数与先前可用子网IP地址确定新的子网号位数
- 进行子网划分后选择一个可用地址分配给对应子网
- 重复先前4步直到划分完成

子网划分的任务

- 确定子网掩码
- 确定网络地址
- 确定子网中第一个可用的IP地址和最后一个可用的IP地址

有等长子网和变长子网两种划分方式

例题（均分）

某单位分配到一个B类IP地址，其net-id为129.250.0.0.该单位有4000台机器，分布在16个不同的地点。如选用子网掩码为255.255.255.0，试给每一个地点分配一个子网掩码号，并算出每个地点主机号码的最小值和最大值4000/16=250，平均每个地点250台机器。如选255.255.255.0为掩码，则每个网络所连主机数=28-2=254>250，共有子网数=28-2=254>16，能满足实际需求。可给每个地点分配如下子网号码

129.250.0.0 为B类地址 其主机号对应16位，最多$ 256 \times 256 -2 $个ip，现有4000台主机平均分配到16个地点
$$
每个地点的主机数: 4000 \div 16 = 250 台\\
表示250台主机需要8位二进制位\\
子网号最大位数: 16 - 8 = 8位\\
最少分为16个可用子网，需要5位\\
子网号最小位数: 5位
$$
给定子网掩码255.255.255.0 所以子网号使用8位

```
1000 0001 1111 1010 0000 0001 0000 0000	为第1个子网	主机ip范围129.250.1.1~129.250.1.254
1000 0001 1111 1010 0000 0010 0000 0000	为第2个子网	主机ip范围129.250.2.1~129.250.2.254
1000 0001 1111 1010 0000 0011 0000 0000	为第3个子网	主机ip范围129.250.3.1~129.250.3.254
1000 0001 1111 1010 0000 0100 0000 0000	为第4个子网	主机ip范围129.250.4.1~129.250.4.254
1000 0001 1111 1010 0000 0101 0000 0000	为第5个子网	主机ip范围129.250.5.1~129.250.5.254
1000 0001 1111 1010 0000 0110 0000 0000	为第6个子网	主机ip范围129.250.6.1~129.250.6.254
1000 0001 1111 1010 0000 0111 0000 0000	为第7个子网	主机ip范围129.250.7.1~129.250.7.254
1000 0001 1111 1010 0000 1000 0000 0000	为第8个子网	主机ip范围129.250.8.1~129.250.8.254
1000 0001 1111 1010 0000 1001 0000 0000	为第9个子网	主机ip范围129.250.9.1~129.250.9.254
1000 0001 1111 1010 0000 1010 0000 0000	为第10个子网	主机ip范围129.250.10.1~129.250.10.254
1000 0001 1111 1010 0000 1011 0000 0000	为第11个子网	主机ip范围129.250.11.1~129.250.11.254
1000 0001 1111 1010 0000 1100 0000 0000	为第12个子网	主机ip范围129.250.12.1~129.250.12.254
1000 0001 1111 1010 0000 1101 0000 0000	为第13个子网	主机ip范围129.250.13.1~129.250.13.254
1000 0001 1111 1010 0000 1110 0000 0000	为第14个子网	主机ip范围129.250.14.1~129.250.14.254
1000 0001 1111 1010 0000 1111 0000 0000	为第15个子网	主机ip范围129.250.15.1~129.250.15.254
1000 0001 1111 1010 0001 0000 0000 0000	为第16个子网	主机ip范围129.250.16.1~129.250.16.254
```

子网划分中路由表中添加了子网掩码

#### 构造超网

使用无分类编址CIDR，使用变长子网掩码VLSM进一步提高IP地址资源利用率。

消除了窗体A类B类C类与划分子网的概念

使用网络前缀类代替网络号和子网号，使IP地址由三级编址又回到了两级编址

![img](计算机网络基础梳理\无分类编址.JPG)

CIDR使用斜线记法 即在IP地址后面加上一个斜线“/”之后写上前缀码位数

如 220.78.168.0/24

一个CIDR地址可用表示很多地址，叫做路由聚合，掩码这一名词仍在使用

例题（地址块子网划分）

一个自治系统有5个局域网，其连接图如图4-55示。LAN2至LAN5上的主机数分别为：91，150，3和15.该自治系统分配到的IP地址块为30.138.118/23。试给出每一个局域网的地址块（包括前缀）

![img](计算机网络基础梳理\构造超网.JPG)

```
地址块: 30.138.118.0
LAN1:3	LAN2:91	LAN3:150	LAN4:3	LAN5:15
以二进制表示:	0001 1110 1000 1010 0111 0110 0000 0000
地址掩码表示:	1111 1111 1111 1111 1111 1110 0000 0000
可分配位数: 9
最大主机数: LAN3 150
子网数量: 5
由主机数最多的子网开始分配

LAN3:150个主机号需要8位二进制数作为主机号 将最后8位作为主机号 地址掩码位数为24 可分配两个子网
子网1范围: 30.138.118.0 ~ 30.138.118.255 地址掩码24位
子网2范围: 30.138.119.0 ~ 30.138.119.255 地址掩码24位
将子网1分配给LAN3，子网2继续分配

LAN2:91 个主机号需要7位二进制数作为主机号 将子网2的最后7位作为主机号 地址掩码位数为25 可分配两个子网
子网2.1范围: 30.138.119.0 ~ 30.138.119.127 地址掩码25位
子网2.2范围: 30.138.119.128 ~ 30.138.119.255 地址掩码25位
将子网2.1分配给LAN2，子网2.2继续分配

LAN5:15 个主机号需要5位二进制数作为主机号 将子网2.2的最后5位作为主机号 地址掩码位数为27 可分配四个子网
子网2.2.1范围 30.138.119.128 ~ 30.138.119.159 地址掩码27位
子网2.2.2范围 30.138.119.160 ~ 30.138.119.191 地址掩码27位
子网2.2.3范围 30.138.119.192 ~ 30.138.119.223 地址掩码27位
子网2.2.4范围 30.138.119.224 ~ 30.138.119.255 地址掩码27位

将子网2.2.1分配给LAN5 子网2.2.2分配给LAN1 子网2.2.3分配给LAN4
```

##### 超网合并网段

判断连续的2个网段是否能够合并，只要第一个网络号能被2整除，就能够通过左移1位子网掩码合并

例如192.168.0.0/24与192.168.1.0/24

![img](计算机网络基础梳理\超网合并网段.JPG)

同理，判断4个网段是否能合并，只要第一个网络号能被4整除就能通过左移两位子网掩码合并4个网段

##### CIDR带来的变化

无分类编址进一步提高了IP地址利用率

路由聚合缩减了骨干网路由器路由表规模

### 地址转换

将IP地址转为数据链路层MAC地址

IP地址与硬件地址的不同在数据链路层有描述

#### 地址解析协议ARP

从网络层使用的IP地址解析出数据链路层使用的硬件地址（点对点链路使用PPP协议不需要ARP协议）

每一个主机/路由器中都存在**ARP高速缓存** 里面存有所在局域网上各主机和路由器IP地址到硬件地址的映射表。

格式为

IP地址	MAC地址	TTL有效时间

##### ARP工作流程

1. 主机A查找ARP缓存中主机B的IP匹配的MAC地址
2. 若没有找到对应映射，将ARP请求包广播到本地网络上的所有主机，主机A的IP地址与MAC地址都在ARP请求中。对应本地网络上除B外其他主机，如果请求IP地址与本机IP不匹配直接丢弃
3. 主机B确认ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中
4. 主机B将包含其MAC地址的ARP响应包直接发送回主机A
5. 主机A接收到B发来的ARP回复消息后用B的IP与MAC地址更新ARP缓存，本机缓存有生存期，生存期结束后重复上述请求

##### ARP四种典型情况

- 发送方主机向本网络另一主机发送IP数据报：ARP直接找目的主机
- 41发送方主机向另一网络主机发送IP数据报：ARP找路由器 剩下交给路由器
- 发送方路由器向本网络主机发送IP数据报：ARP找目的主机
- 发送方路由器向另一网络主机发送IP数据报：ARP找到另一个路由器剩下的由另一个路由器解决

ARP请求包

发送方MAC / 发送方IP / 目标硬件地址（未知填0）/目标IP

ARP响应包

发送方MAC / 发送方IP / 目标MAC / 目标IP

ARP包封装在物理层网络的帧中传输，ARP请求是一个广播帧

### 路由协议

任意两个IP之间的路线规划

路由器对IP数据报进行转发的关键步骤：查路由表

#### 路由选择协议

- 内部网关协议
- 外部网关协议

##### 内部网关协议 RIP路由信息协议

Routing Information Protocol

RIP是一种分布式的、基于距离向量的路由选择协议

RIP协议要求网络中的每一个路由器都要维护从它到其他每一个目标网络的距离记录

RIP认为一个好的路由时它通过的路由器数目少“距离短”

RIP允许一条路径最多只能包含15个路由器16代表不可达

RIP不能再两个网络之间同时使用多条路由

RIP核心：通过分布式交换寻找最短路核心算法bellman-ford

**RIP协议的三个特点**

- 之和相邻路由器交换信息
- 交换的是当前本路由器所知道的全部信息（路由表）
- 按固定时间间隔交换路由信息，网络拓扑发生变化也及时通过

**路由表建立过程**

- 路由器刚开始工作时只知道直接相连的网络距离为1
- 和相邻路由器交换并更新路由信息
- 经过若干次更新后所有路由器都知道到达本自治系统中任何网络的距离和下一跳

**距离向量算法**

对于每一个相邻路由器（X）发送过来的RIP报文，执行以下步骤

1. 对地址为X的相邻路由器（X）发来的RIP报文，修改报文中的所有项目的下一跳地址都改为X，并把距离加1
2. 对修改后的RIP报文的每一个项目执行以下步骤
   - 若原来路由表中没有目标网络，直接加入路由表
   - 原来路由表中有目标网络，且下一跳地址为X，就直接用新的替换旧的
   - 如果下一跳地址不为X则判断收到的距离是否小于当前距离，如果小于当前距离进行更新，否则什么都不做（相等也什么都不做）
3. 若3分钟没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达（距离16）
4. 返回

RIP首部（不重要）

![img](计算机网络基础梳理\RIP首部.JPG)

**RIP协议特点**

好消息传的快，坏消息传的慢

**RIP存在问题**

网络出现故障，要经过较长时间才能传到所有路由器

收到故障报文前可能发送原来的报文，之后回开始循环直到距离超过16

**RIP优点**

实现简单开销小

**缺点**

RIP最大距离15限制了网络规模

由于交换整个路由表，随着网络规模增大开销增加

坏消息传播的慢，使更新过程收敛时间过长

###### 例题

例题1：

假定网络中的路由器B的路由表有如下的项目（这三列分别表示“目的网络”、“距离”和“下一跳路由器”）

```
         N1     7     A

​         N2     2     B

​         N6     8     F

​         N8     4     E

​         N9     4     F
```



现在B收到从C发来的路由信息（这两列分别表示“目的网络”“距离”）：

```
         N2     4

​         N3     8

​         N6     4

​         N8     3

​         N9     5
```

试求出路由器B更新后的路由表（详细说明每一个步骤）

- B原路由表

  

  

  | 目的网络 | 距离 | 下一跳 |
  | -------- | ---- | ------ |
  | N1       | 7    | A      |
  | N2       | 2    | C      |
  | N6       | 8    | F      |
  | N8       | 4    | E      |
  | N9       | 4    | F      |

  

- 修改路由器C发送来的所有项目

  

  

  | 目的网络 | 距离      | 下一跳 |
  | -------- | --------- | ------ |
  | N2       | 4 + 1 = 5 | C      |
  | N3       | 8 + 1 = 9 | C      |
  | N6       | 4 + 1 = 5 | C      |
  | N8       | 3 + 1 = 4 | C      |
  | N9       | 5 + 1 = 6 | C      |

  

- 根据每一条信息更新B路由表

  ```
  N2 4 C N2在B路由表中存在，且下一跳为C，进行替换 将原表N2 2 C更新为N2 5 C
  N3 9 C N3在B路由表中不存在，直接加入B路由表中 N3 9 C
  N6 5 C N6在B路由表中存在，下一跳地址不为C，但距离5小于原距离8，将原表N6 8 F更新为N6 5 C
  N8 4 C N8在B路由表中存在，下一跳地址不为C，距离4等于原距离4，不进行操作
  N9 4 C N9在B路由表中存在，下一跳地址不为C，距离6大于原距离4，不进行操作
  ```

- B更新后的路由表

  
  
  
  
  | 目的网络 | 距离 | 下一跳 |
  | -------- | ---- | ------ |
  | N1       | 7    | A      |
  | N2       | 5    | C      |
  | N3       | 9    | C      |
  | N6       | 5    | C      |
  | N8       | 4    | E      |
  | N9       | 4    | F      |

例题2：

假定网络中的路由器A的路由表有如下的项目（格式同上题）：

```
      N1      4      B

​      N2      2      C

​      N3      1      F

​      N4      5      G
```

  现将A收到从C发来的路由信息（格式同上题）：

```
      N1      2

​      N2      1

​      N3      3

​      N4      7
```

试求出路由器A更新后的路由表（详细说明每一个步骤）

- A原路由表

  

  

  | c    |      |      |
  | ---- | ---- | ---- |
  | N1   | 4    | B    |
  | N2   | 2    | C    |
  | N3   | 1    | F    |
  | N4   | 5    | G    |

- 修改路由器C发送来的所有项目

  

  

  | 目的网络 | 距离      | 下一跳 |
  | -------- | --------- | ------ |
  | N1       | 2 + 1 = 3 | C      |
  | N2       | 1 + 1 = 2 | C      |
  | N3       | 3 + 1 = 4 | C      |
  | N4       | 7 + 1 = 8 | C      |

- 根据每一条信息更新A路由表

  ```
  N1 3 C N1在B路由表中存在，下一跳地址不为C，但距离3小于原距离4，将原表N1 4 B更新为N1 3 C
  N2 2 C N2在B路由表中存在，下一跳地址为C，直接更新，将原表N2 2 C替换为N2 2 C
  N3 4 C N3在B路由表中存在，下一跳地址不为C，距离4大于原距离1，不进行操作
  N4 8 C N4在B路由表中存在，下一跳地址不为C，距离8大于原距离5，不进行操作
  ```

- A更新后的路由表

  
  
  
  
  | 目的网络 | 距离 | 下一跳 |
  | -------- | ---- | ------ |
  | N1       | 3    | C      |
  | N2       | 2    | C      |
  | N3       | 1    | F      |
  | N4       | 5    | G      |


##### 内部网关协议OSPF

用于克服RIP缺点，基于Dijkstra（SPF）通过共享自己的链路状态信息，构建网络的全局拓扑图，从而计算最短路径，构建自己路由表。

- 向本自治系统中所有路由器发送信息
- 发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。
- 只有当链路状态发生变化时，路由器才用**洪泛法**向所有路由器发送此信息

##### 外部网关协议BGP

是不同自治系统的路由器之间交换路由信息的协议。 

寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由

![img](计算机网络基础梳理\路径选择协议对比.JPG)

**防止环路**

如果某台BGP路由器从其外部对等体收到某条路由的AS_PATH中包含有自己的AS号那么该路由器就知道出现了环路，因而丢弃该路由。

AS：自治系统

### 分组转发

#### IP数据报

**首部**

![img](计算机网络基础梳理\IP首部.JPG)

固定首部20字节

- 版本4位：IP协议版本

- 首部长度4位：所以首部最大长度60字节

- 分区服务8位：只有用分区服务时才起效

- 总长度16位：首部和数据之和的长度，单位为字节，最大65535字节

  总长度必须不超过最大传输单元MTU

- 标识16位：产生IP数据报标识

- 标志3位：只有前两位有意义 最低为位MF = 0代表这是最后分片 MF=1代表还有分片，中间一位为DF DF=0时才允许分片。

- 片偏移13位，指出较长的分组在分片后某片在原分组中的相对位置。（以8字节为偏移单位）

- 生存时间8位：TTL数据报的寿命

- 协议：指出IP数据报携带的数据是那种协议

  1：ICMP	2：IGMP	4：IP	6：TCP	8：EGP	9：IGP	17：UDP	41：IPv6	50：ESP	89：OSPF

- 首部检验和

  只检验首部不包括数据部分， 首部二进制16位对其相加后（若最高位有进位则加至最低位）取反便是检验和

  例题

  设IP数据报使用固定首部，其各字段的具体数值如图所示（除IP地址外，均为十进制表示）。试用二进制运算方法计算应当写入到首部检验和字段中的数值

  <table>
      <tr>
          <td rowspan=6>首部</td>
          <td rowspan=5>固定部分</td>
          <td>版本4</td>
          <td>首部长度4</td>
          <td colspan=2>区分服务8</td>
          <td colspan=4>总 长 度16</td>
      </tr>
      <tr>
          <td colspan=4>标识16</td>
          <td>标  志 4</td>
          <td colspan=3>片偏移12</td>
      </tr>
      <tr>
          <td colspan=2>生存时间8</td>
          <td colspan=2>协议8</td>
          <td colspan=4>首 部 检 验 和 16</td>
      </tr>
      <tr>
          <td colspan=8>源地址32</td>
      </tr>
      <tr>
          <td colspan=8>目的地址32</td>
      </tr>
      <tr>
          <td>可变部分</td>
          <td colspan=6>可选字段（长度可变）</td>
          <td colspan=2>填充</td>
      </tr>
      <tr>
          <td ></td>
          <td ></td>
          <td colspan=8>数据部分</td>
      </tr>
  </table>

  <table>
      <tr>
          <td>4</td>
          <td>5</td>
          <td colspan=2>0</td>
          <td colspan=4>28</td>
      </tr>
      <tr>
          <td colspan=4>1</td>
          <td>0</td>
          <td colspan=3>0</td>
      </tr>
      <tr>
          <td colspan=2>4</td>
          <td colspan=2>17</td>
          <td colspan=4>首 部 检 验 和 </td>
      </tr>
      <tr>
          <td colspan=8>10.12.14.5</td>
      </tr>
      <tr>
          <td colspan=8>12.6.7.9</td>
      </tr>
  </table>

  <table>
      <tr>
          <td>0100</td>
          <td>0101</td>
          <td colspan=2>0000 0000</td>
          <td colspan=4>0000 0000 0001 1100</td>
      </tr>
      <tr>
          <td colspan=4>0000 0000 0000 0001</td>
          <td>0000</td>
          <td colspan=3>0000 0000 0000</td>
      </tr>
      <tr>
          <td colspan=2>0000 0100</td>
          <td colspan=2>0001 0001</td>
          <td colspan=4>首 部 检 验 和 </td>
      </tr>
      <tr>
          <td colspan=8>0000 1010 0000 1100 0000 1110 0000 0101</td>
      </tr>
      <tr>
          <td colspan=8>0000 1100 0000 0110 0000 0111 0000 1001</td>
      </tr>
  </table>

  <table>
      <tr>
          <td>0100</td>
          <td>0101</td>
          <td>0000</td>
          <td>0000</td>
          <td>0000</td>
      	<td>0000</td>
          <td>0001</td>
          <td>1100</td>
      </tr>
      <tr>
          <td>0000</td>
          <td>0000</td>
          <td>0000</td>
          <td>0001</td>
          <td>0000</td>
          <td>0000</td>
          <td>0000</td>
          <td>0000</td>
      </tr>
      <tr>
          <td>0000</td>
          <td>0100</td>
          <td>0001</td>
          <td>0001</td>
          <td colspan=4>首 部 检 验 和 </td>
      </tr>
      <tr>
          <td>0000</td>
          <td>1010</td>
          <td>0000</td>
          <td>1100</td>
          <td>0000</td>
          <td>1110</td>
          <td>0000</td>
          <td>0101</td>
      </tr>
      <tr>
          <td>0000</td>
          <td>1100</td>
          <td>0000</td>
          <td>0110</td>
          <td>0000</td>
          <td>0111</td>
          <td>0000</td>
          <td>1001</td>
      </tr>
  </table>

  ```
  按16位对齐
  0100 0101 0000 0000
  0000 0000 0001 1100
  0000 0000 0000 0001
  0000 0000 0000 0000
  0000 0100 0001 0001
  0000 1010 0000 1100
  0000 1110 0000 0101
  0000 1100 0000 0110
  0000 0111 0000 1001
  -------------------
  0111 0100 0100 1110
  1000 1011 1011 0001
  ```

  所以检测和为1000 1011 1011 0001

- 源地址32位

- 目的地址32位

##### 分片

若将总长度为3820字节的数据报分片为长度不超过1420的数据报片

![img](计算机网络基础梳理\IP分片.JPG)

##### 分组转发流程

每个路由器都有路由表

路由表存储到达每一个主机所在网络的路径信息

路由表结构





| 目的网络 | 下一跳 | 交付接口 |

根据下一跳地址确定下一跳路由器多次间接交付后直接交付。

查询顺序

- 特定主机路由
- 目的网络路由
- 默认路由

分组转发算法（掩码存在时采用最长前缀匹配）

1. 从数据报中提取首部信息得到IP地址提取目的网络地址
2. 若目的网络与此路由器直接相连则直接交付
3. 查找路由表 特定主机$\rightarrow$目的网络$\rightarrow$默认路由
4. 否则报告错误

##### 例题

设某路由器建立了如下路由表







| 目的网络      |                ip二进制                 |    子网掩码     | 子网掩码二进制                          | 下一跳 |
| ------------- | :-------------------------------------: | :-------------: | --------------------------------------- | ------ |
| 128.96.39.0   | 1000 0000 0110 0000 0010 0111 0000 0000 | 255.255.255.128 | 1111 1111 1111 1111 1111 1111 1000 0000 | 接口m0 |
| 128.96.39.128 | 1000 0000 0110 0000 0010 0111 1000 0000 | 255.255.255.128 | 1111 1111 1111 1111 1111 1111 1000 0000 | 接口m1 |
| 128.96.40.0   | 1000 0000 0110 0000 0010 1000 0000 0000 | 255.255.255.128 | 1111 1111 1111 1111 1111 1111 1000 0000 | R2     |
| 192.4.153.0   | 1100 0000 0000 0100 1001 1001 0000 0000 | 255.255.255.192 | 1111 1111 1111 1111 1111 1111 1100 0000 | R3     |
| *（默认）     |                    -                    |        -        | -                                       | R4     |

 现共收到5个分组，求下一跳





| 目的网络      | ip地址                                  | 255.255.255.128与                                        | 255.255.255.192与                                        | 对应ip      | 下一跳 |
| ------------- | --------------------------------------- | -------------------------------------------------------- | -------------------------------------------------------- | ----------- | ------ |
| 128.96.39.10  | 1000 0000 0110 0000 0010 0111 0000 1010 | 1000 0000 0110 0000 0010 0111 0000 0000（128.96.39.0）   | 1000 0000 0110 0000 0010 0111 0000 0000（128.96.39.0）   | 128.96.39.0 | 接口m0 |
| 128.96.40.12  | 1000 0000 0110 0000 0010 1000 0000 1100 | 1000 0000 0110 0000 0010 1000 0000 0000（128.96.40.0）   | 1000 0000 0110 0000 0010 1000 0000 0000（128.96.40.0）   | 128.96.40.0 | R2     |
| 128.96.40.151 | 1000 0000 0110 0000 0010 1000 1001 0111 | 1000 0000 0110 0000 0010 1000 1000 0000（128.96.40.128） | 1000 0000 0110 0000 0010 1000 1000 0000（128.96.40.128） | *           | R4     |
| 192.4.153.17  | 1100 0000 0000 0100 1001 1001 0001 0001 | 1100 0000 0000 0100 1001 1001 0000 0000（192.4.153.0）   | 1100 0000 0000 0100 1001 1001 0000 0000（192.4.153.0）   | 192.4.153.0 | R3     |
| 192.4.153.90  | 1100 0000 0000 0100 1001 1001 0101 1010 | 1100 0000 0000 0100 1001 1001 0000 0000（192.4.153.0）   | 1100 0000 0000 0100 1001 1001 0100 0000（192.4.153.64）  | *           | R4     |



例题2

如图，网络145.13.0.0/16划分为四个子网$N_1,N_2,N_3,N_4$，这四个子网与路由器R链接的接口分别为m0,m1,m2,m3。路由器R的第五个接口m4链接至互联网

![img](计算机网络基础梳理\路径转发.JPG)

1. 给出路由器R的路由表

   

   

   | 目的ip       | 地址掩码      | 下一跳          |
   | ------------ | ------------- | --------------- |
   | 145.13.0.0   | 255.255.192.0 | 直接交付 接口m0 |
   | 145.13.64.0  | 255.255.192.0 | 直接交付 接口m1 |
   | 145.13.128.0 | 255.255.192.0 | 直接交付 接口m2 |
   | 145.13.192.0 | 255.255.192.0 | 直接交付 接口m3 |
   | 其他         | ~             | ~ 接口m4        |

2. 路由器R收到一个分组，其目的地址是145.13.160.78给出这个分组如何转发

   拆包首部查找目标网络地址$\rightarrow$根据IP:145.13.160.78找到目标网络145.13.128.0$\rightarrow$由接口m2直接交付

#### ICMP（网际控制报文协议）

##### 概念与作用

- IP协议为不可靠传输
- 转发过程中可能丢失数据
- 需可靠传输要实现一种机制，报告数据报转发中遇到的各种错误

ICMP数据包是封装在IP数据报中的

##### ICMP数据报格式

![img](计算机网络基础梳理\ICMP数据报.JPG)

##### ICMP报文种类

- ICMP差错报告报文
- ICMP询问（请求/应答）报文

##### ICMP报文类型

![img](计算机网络基础梳理\ICMP报文类型.JPG)

##### ICMP差错报告报文

- 终点不可达

  路由器或主机不能交付数据时向源点发送

- 时间超时

  收到生存时间为0的数据报，时丢弃并向源点发送

- 参数问题

  路由器或主机收到的数据报首部有字段的值不正确时丢弃并向源点发送

- 改变路由（重定向）

  路由器把报文把报文发送给主机，让主机直到下次将数据报发给另外路由器（可通过更好的路由）

##### 不应发送ICMP差错报告报文的情况

- 对ICMP差错报告报文，不再发送ICMP差错报告报文
- 对于第一个分片后的所有后续分片都不发生差错报告报文
- 对具有多播地址的数据报，都不发送ICMP差错报告报文
- 对具有特殊地址（127.0.0.0或0.0.0.0）不发送ICMP差错报告报文

##### ICMP询问报文

- 回送请求和回答

  由主机或路由器向特定主机发出询问，收到的主机必须给源主机或路由器发送ICMP回送回答报文（判断是否可达PING）

- 时间戳请求和回答

  请某台主机或路由器回答当前日期和时间（32位 从1900.1.1开始的秒数）

### NAT&VPN

#### 网络地址转换 NAT

实现在专用网络上使用专用地址的主机于互联网主机通信

##### 地址转换

- 离开专用网时：替换源地址，将内部地址替换为全球地址
- 进入专用网络时：替换目标地址，将全球地址替换为内部地址

专用网内部主机不能充当服务器

##### NAPT

把运输层端口也利用，使使多个本地地址主机工业一个NAT路由器上的全球地址。

#### 虚拟专用网络VPN

利用互联网作为本机构各专用网之间的通信载体

不使用通信专线实现专用网的效果

- 隧道技术

### IPv6

解决IPv4不够使用

- 地址128位
- 基本首部40字节，有灵活的扩展首部
- 8字节对其

首部结构

![img](计算机网络基础梳理\IPv6.JPG)采用冒号十六进制记法

可用零压缩（只能一次）

相邻的0用::代替

## 运输层（传输层）

 ### 传输层协议概述

#### 传输层地位

- 面向通信的最高部分，用户功能的最低层
- 只有网络边缘部分主机协议栈才有传输层

#### 传输层作用

- 为应用程序提供逻辑通信服务（真正端点是主机中的进程）
- 在不可靠网络服务上提供可靠服务

#### 两个主要协议

- 用户数据报协议UDP
- 传输控制协议TCP

#### 端口

网络系统不能用操作系统进程标识符来区分不同进程所以使用协议端口号解决

**端口**：应用进程在传输层的地址

**服务器端口号**

熟知端口 0 ~ 1023

```
FTP: 21	TELNET: 23	SMTP: 25	DNS: 53	TFTP: 69
HTTP: 80	SNMP: 161	HTTPS: 443
```

登记端口 1024 ~ 49151

**客户端端口号**（短暂端口号）

49153 ~ 65535

### 用户数据报协议UDP

#### 主要特点

- UDP是无连接的
- UDP尽最大努力交付，不保证可靠交付
- UDP面向报文
- UDP没有拥塞控制
- UDP支持一对一、一对多、和多对多交互通信
- UDP首部开销小 8字节

#### 报文首部格式

![img](计算机网络基础梳理\UDP首部.JPG)

UDP检验和 12字节伪首部，首部与数据一同检测

##### 例题

例题1：如果程序愿意通过UDP完成可靠传输，这可能吗？

可能，只要UDP手动实现了与TCP相同的确认、重传便可做到可靠传输，大部分关键帧+普通帧的应用中的关键帧便是如此实现的。

例题2：某个应用进程使用运输层的用户数据报UDP，然而继续向下交给IP层后，又封装成IP数据报。既然都是数据报，可否跳过UDP而直接交给IP层？哪些功能UDP提供了但IP没提提供？

不能跳过，IP数据报只能找到对应的主机，找不到主机开放的对应端口，而UDP可以。

例题3：一个UDP用户数据的数据字段为8192季节。在数据链路层要使用以太网来传送。试问应当划分为几个IP数据报片？说明每一个IP数据报字段长度和片偏移字段的值。

UDP数据报总长 8192 + 8 = 8200

以太网数据部分最大长度为1500，但是需要减去ip的首部20，因为问的是ip数据报的字段长度，所以不需要减去其中的UDP首部，最长帧中ip数据字段长度为1480。

8200 $\div$ 1480 = 5 …… 800.

所以前5个ip数据报数据字段长度为1480，最后一个ip数据报数据字段长度为800. 

1480 $\div $ 8 = 185

片偏移为0, 185, 370, 555, 925

例题4：UDP用户数据报的首部十六进制表示是：06 32 00 45 00 1C  E2 17.试求源端口、目的端口、用户数据报的总长度、数据部分长度。这个用户数据报是从客户发送给服务器发送给客户？使用UDP的这个服务器程序是什么？

首部: 06 32 00 45 00 1C E2 17

源端口: 06 32 $\rightarrow$ 1571

目的端口: 00 45 $\rightarrow $ 69

长度: 00 1C $\rightarrow $  28

检验和: E2 17 $\rightarrow$ 60449 $\rightarrow$ 1110 1100 0010 0001

目的端口小于1023所以是由客户端发给服务器，69是TFTP

### 传输控制协议TCP

#### TCP主要特点

- TCP是面向链接的（建立-传输-释放）
- 每条TCP链接只能有两个端点
- TCP提供可靠交付服务（无差错、不丢失、不重复、按序到达）
- 全双工
- 面向字节流（TCP将应用程序交下来的数据看成一串无结构的字节流）

#### TCP报文段首部

![img](计算机网络基础梳理\TCP首部.JPG)

- 源端口和目的端口（各占2字节）

- 序号字段（4字节）

  TCP链接中传送的数据流中的每一个字节都有一个编号

  序号字段指的是本报文段所发送的数据的第一个字节的序号

  [0,$2^{32}$-1]共$2^{32}$个序号，增加到$2^{32}-1$后下一个序号又会回到0

- 确认号（4字节）

  期望收到对方的下一个报文段的数据的第一字节的序号

- 数据偏移（4**位**）

  指出TCP报文的数据其实处距TCP报文段的起始处有多远

  以4字节（32位）为单位，最大60字节

- 保留字段（6**位**）

  当前为0 保留为今后使用

- 紧急URG（1**位**）

  URG = 1时表明紧急指针字段有效，告诉系统此报文中有紧急数据，应尽快传送

- 确认ACK（1**位**）

  ACK = 1时确认号字段才有效

- 推送PSH（1**位**）

  收到PSH = 1应尽快交付接收应用程序进程，不再等待缓冲区都填满再向上交付

- 复位RST（1**位**）

  RST = 1表明TCP链接中出现严重差错（主机崩溃等），必须释放连接，然后重新建立传输连接

- 同步SYN（1**位**）

  SYN = 1而ACK = 0时，表明这是一个连接请求报文段，对方若同意建立连接，则应在响应报文段中使用SYN = 1和ACK = 1

- 终止FIN（1**位**）

  用来释放一个连接  FIN = 1表明此报文段的发送端的数据已发送完毕，并要求释放运输连接

- 窗口字段（2字节）

  接收窗口大小，从本报文段首部确认号算起接收方目前允许对方发送的数据量（单位字节）用于进行流量控制

- 检验和（2字节）

  检验和字段检验包括首部和数据这两部分，在计算检验和时，要在TCP报文前面加上12字节伪首部

- 紧急指针字段（2字节）

- 本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据最前方）

- 选项字段（非固定首部长度可变）

- 填充

  填充至4字节对齐



### 可靠传输

- 无差错
- 无丢失
- 无重复
- 顺序接收

#### 理想传输

- 传输信道不产生差错
- 不管发送方以多快的速度发送，接收方总是来得及处理收到的数据

#### 停止等待协议

- 每发送完一个报文段，就停止发送，等待对方确认，收到确认后再发送下一个分段。
- 全双工通信，双方既是发送方也是接收方

##### 超时重传时间与基本原则

- 重传时间： 比往返时间RTT要长一些
- 实现重发： 缓存已发送的分段的副本
- 避免重复： 为每个分段编号

发送方再发送完一个报文后，如果再超时重传时间内没有收到确认，就自动重发该报文段

接收端如果收到重复的报文段，则丢弃该报文段并发送报文段的确认报文

#### 自动重传请求ARQ

基于以上确认和重传的可靠传输协议称为自动重传请求ARQ 

重传自动进行，不需要接收方请求发送方重传某个分段

#### 连续ARQ协议

通过流水线传输提高信道利用率

- 通过滑动窗口协议实现连续ARQ
- 滑动窗口是TCP协议的精髓，不止实现ARQ，还实现**流量控制**和**拥塞控制**

**连续ARQ原理**

- 发送方有一个发送窗口，位于发送窗口内的分段都可以连续发送出去，而不需要等待对方确认
- 发送方每收到一个确认，就把发送窗口向前滑动一个分段的位置

**解决ARQ差错、丢失、迟到**

- 接收端： 收到一个确认一个
- 发送端：超时重传

**解决连续ARQ差错、丢失、迟到**

1. 选择确认：哪一个分段的确认没有收到就重传哪个分段

   前提：接收方能给出明确的确认

   选择重传 SR协议 实现复杂度高

2. Go-back-N重传

   接收方无法给出明确确认，采用**累计确认**的方式，只确认按需到达的的分段

   重传：超时后将没有确认的分段全部重发

   回退重传 GBN协议

   - 如果发送方发送了前 5 个分段，而中间的第 3 个分段丢失了。这时接收方只能对前两个分段发出确认。发送方无法知道后面三个分段的下落，而只好把后面的三个分段都再重传一次。
   - 这就叫做 Go-back-N（回退 N），表示需要再退回来重传已发送过的 N 个分段

**TCP是一种连续ARQ协议，综合了SR与Go-back-N**

#### 累计确认

- 不必对收到的分段逐个确认，而是累计一段时间后对按序到达的最后一个分段发送确认
- 优点：容易实现，即使确认丢失也不必重传
- 缺点：不能像发送方反映出已经正确收到的所有分组信息

#### 窗口相关

- 后沿 
  - 不动 没有收到新的确认
  - 前移 收到新的确认
- 前沿
  - 不动 没有收到新的确认
  - 后移 对方通知窗口缩小（一半不出现）
  - 前移 其他情况

在双方建立连接的三次握手过程中要确定窗口大小

A与B建立连接 B告诉A自己的接收窗口大小

A根据B接收窗口大小设置发送窗口大小

窗口初始位置位于缓存最小编号的位置

#### TCP超时重传时间设置

- 太短会引起多报文段不必要传输
- 太长会使网络空闲时间增大
- TCP采取自适应算法，记录一个报文发出到收到确认的时间RTT

加权平均往返时间$RTT_s$初始为第一次测量的RTT，之后每次按下式计算

$RTT_S = (1-\alpha) \times (旧RTT_S) + \alpha \times(新的RTT样本)$

0 <= $\alpha$ < 1若$\alpha$接近于0，标识RTT更新较慢，接近于1表示更新较快

RFC2988推荐$\alpha = \frac 18$

重传超时$RTO = RTT_S + 4 \times RTT_D$ 

RTT偏差加权平均值$RTT_D$

$RTT_D = (1- \beta) \times (旧RTT_D) + \beta \times|RTT_S - 新RTT样本|$

推荐$\beta = \frac 14$

#### TCP流量控制

让发送方的发送速率不要太快，既让接收方来得及接收，也不使网络发生拥塞

利用滑动窗口可以方便实现流量控制

##### 滑动窗口进行流量控制

让接收端通知发送端接收窗口大小

举例

![img](计算机网络基础梳理\TCP流量控制.JPG)

**可能发生死锁**

- 接收端通知发送端接收窗口大小的报文丢失

- 接收端一直等待发送端发送的数据

- 发送端一直等待接收端发送非零窗口通知

**解决死锁**

- TCP为每一个连接设有持续计时器

- 只要有一方收到另一方的零窗口通知，就启动持续计时器

- 若持续计时器时间到期，就发送零窗口探测报文，接收到探测报文的一方在确认这个报文时就给出了现在的窗口值
- 如果窗口仍然是0，则收到确认报文的一方重设持续计时器
- 若不是零，死锁被打破

#### 拥塞控制

##### 拥塞

某段时间，对网络中某资源的需求超过了该资源所能提供的可用部分，网络性能变坏（网络吞吐量随输入负荷的增大而下降），这种现象称为拥塞

##### 拥塞控制本质

防止过多数据注入网络中，使网络中的路由器或链路不过载

##### 拥塞控制的解决方法

- **开环控制**：

  在设计网络时先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。适用于用户固定的小型网络

- **闭环控制**：

  基于反馈环路概念，属于闭环控制的有以下几种措施

  - 检测网络系统以便检测到拥塞在何时、何处发生
  - 将拥塞发生的信息传送到可采取行动的地方
  - 调整网络系统的运行以解决出现的问题

  TCP采取的基于窗口的方法进行拥塞控制属于闭环控制

  TCP发送方维护一个拥塞窗口CWND

  - 拥塞窗口大小取决于网络拥塞程度，并动态变化
  - 发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量

  真正的发送窗口值 = min(接收窗口值,拥塞窗口值)

##### 拥塞的判断

- 重传定时器超时
- 收到3个相同的确认（ACK）

##### TCP拥塞控制算法

- 慢开始
- 拥塞避免
- 快重传
- 快恢复

**慢开始**

由小到大逐渐增大拥塞窗口的数值

拥塞窗口初始值cwnd

旧规定：1至2个发送方最大报文段SMSS的值

新规定SFC5681：不超过2至4个SMSS的数值

慢开始门限ssthresh（状态变量）：防止拥塞窗口cwnd过大引起网络拥塞

拥塞窗口cwnd控制方法：在每收到一个**对新的报文段的确认**后，可以把拥塞窗口cwnd每次增加量最多一个SMSS的值

![img](计算机网络基础梳理\慢开始.JPG)

慢开始门限ssthresh使用

- 当cwnd < ssthresh时使用慢开始算法
- 当cwnd > ssthresh时停止使用慢开始转而使用拥塞避免算法
- 当cwnd = ssthresh时既可以使用慢开始也可以使用拥塞避免

##### 拥塞避免算法

**思路**

让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1而不是加倍（加法增大）

##### 当网络出现拥塞（重传定时器超时）

$ssthresh = max(\frac {cwnd}2, 2)$

$cwnd = 1$

执行慢开始算法

##### 快重传

发送方只要一连收到三个重复确认就直到立即进行重传，这样就不会出现超时，发送方也不会误认为出现了网络拥塞

##### 快恢复

- 慢开始门限$ssthresh = \frac {cwnd}2$

- 新拥塞窗口cwnd = 慢开始门限ssthresh

- 开始执行拥塞避免算法

![img](计算机网络基础梳理\拥塞控制.JPG)

##### 例题

例题1：设TCP的ssthresh的初始值为8(单位为报文段)。当拥塞窗口上升到12时网络发生了超时，TCP使用慢开始和拥塞避免。试分别求出第1次到第15次传输的各拥塞窗口大小。你能说明拥塞控制窗口每一次变化的原因吗？ 答案：拥塞窗口大小分别为：1，2，4，8，9，10，11，12，1，2，4，6，7，8，9.

- 第一轮次

  cwnd = 1 (慢开始cwnd初始值)

- 第二轮次

  cwnd = 2（慢开始指数增长）

- 第三轮次

  cwnd = 4  (慢开始指数增长)

- 第四轮次

  cwnd = 8  (慢开始指数增长达到ssthresh)

- 第五轮次

  cwnd = 9  (拥塞避免线性增长)

- 第六轮次

  cwnd = 10(拥塞避免线性增长)

- 第七轮次

  cwnd = 11(拥塞避免线性增长)

- 第八轮次

  cwnd = 12(拥塞避免线性增长)

- 第九轮次

  cwnd = 1 sshtresh = 6(重传定时器超时)

- 第十轮次

  cwnd = 2（慢开始指数增长）

- 第十一轮次

  cwnd = 4（慢开始指数增长）

- 第十二轮次

  cwnd = 6（慢开始指数增长达到ssthresh）

- 第十三轮次

  cwnd = 7（拥塞避免线性增长）

- 第十四轮次

  cwnd = 8（拥塞避免线性增长）

- 第十五轮次

  cwnd = 9（拥塞避免线性增长）



### 传输连接的三个阶段

- 连接建立
- 数据传送
- 连接释放

#### 建立连接过程中的三个问题

- 要使每一方能够确知对方存在
- 允许双方协商一些参数（最大窗口值、是否使用窗口扩大选项和时间戳选项）
- 能够传输实体资源（缓存大小、连接表中的项目）进行分配

#### 客户端-服务器方式

- 主动发起连接建立的应用进程叫客户（client）
- 被动等待连接建立的应用进程叫服务器（server）

#### TCP连接的建立

- TCP建立连接的过程叫做握手
- 握手需要在客户端和服务之间交换三个TCP报文段，叫做**三报文握手**（三次握手）
- 采用三报文握手主要是为了防止已失效的连接请求报文突然又传输到了，而产生错误。

##### 建立过程

- 客户机向服务器发送连接请求报文段

  首部同步位 SYN = 1 选择序号 seq = x表明本报文传送数据的第一个数据字节的序号为x ACK（确认） = 0

- 服务器收到连接请求报文后，若同意，则发回确认报文段

  同步位 SYN = 1 ACK（确认） = 1 确认号ack  = x + 1，自己选择序号seq = y

- 客户搜到确认报文后向服务器发送确认报文 ACK = 1 确认号 = y + 1

  客户TCP通知上层应用进程，连接已建立。（本段已经可以传送数据）

##### 为何需要第三次握手

为了防止已失效的连接请求报文段突然达到服务器（如果没有第三次握手，服务器在发送确认报文后以为链接已经建立，等待接收数据，浪费资源）

若有第三次握手，上述连接无法建立

#### TCP连接的释放

- 数据传输结束后，通信双方都可以释放连接
- TCP连接的释放过程叫四报文握手（四次挥手）

##### 释放过程

假设A与B要释放TCP连接

- A的应用程序进程向其TCP发出连接释放报文段，并停止发送数据，主动关闭TCP连接，A把连接释放报文段 FIN = 1 序号seq = u等待B确认

- B收到释放报文，发送确认 ACK = 1 确认号 ack = u + 1 序号seq = v B的TCP进程通知高层应用程序进程，此时A到B的方向连接释放，TCP处于半关闭状态但此时B若向A发送数据A仍要接收

- 若B已经没有要向A发送的数据，其应用程序进程也要通知TCP释放连接

  发送连接释放报文 FIN = 1 ACK=1 序号seq =  w 确认号 ack = u + 1

- A接到B的连接释放报文，必须发出确认 ACK = 1 确认号 ack = w + 1序号 seq = u + 1

- B收到A的确认报文后关闭TCP连接

- A等待2MSL后关闭TCP连接

