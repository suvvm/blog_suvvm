---
title: GC算法
date: 2020-03-30 21:22:24
categories:
- Java
tags:
- GC
---

# GC算法

## 引用计数算法

为每个对象维护一个引用计数，创建新对象和增加对象引用的时候就将引用计数加一，每当一个对象指针被移除时指针指向的对象的引用计数就减一，当对象的引用次数降为0时将会删除对象并回收内存。

引用计数算法无法处理循环引用问题。

## 标记清除算法 

为每个对象维护一个标记位，当可用内存被耗尽时程序会暂停运行触发GC进入标记阶段，将当前依旧存活的对象标记一遍，之后进入清除阶段，将所有没有标记的对象清除后恢复运行。

标记清除算法运行时会将整个程序暂停且会导致空间碎片化。

## 标记整理算法

为每个对象维护一个标记位，当可用内存被耗尽时程序会暂停运行触发GC进入标记阶段，标记阶段与标记-清除算法相同，之后进入整理阶段，将所有的存活对象向堆低移动并清除所有其它空间。

标记整理算法解决了空间碎片化问题，但运行时依旧会使整个程序暂停。

## 复制算法

将内存分为大小相等的2块，开始运行时所有的对象都将创建在第一块内存中，当第一块内存空间耗尽时会触发GC将所有存活对象复制到第二块内存中并清空第一块内存，这时再创建对象将存储在第二块内存中，当第二块内存满后将触发GC将所有存活对象复制回第一块内存中，以此类推。

复制算法回造成部分内存空间的浪费，且当存活对象数量较多时性能将大幅下降。

## 分代收集

内存空间被分为新生代与老年代，新生代又分为3部分Eden From To 比例约为8 : 1 : 1

GC过程如下

1. 创建对象在Eden区，Eden区空间耗尽后触发MinorGC，将Eden区存活的对象复制到From区并清空Eden区。
2. 当再次触发MinorGC时会扫描Eden区与From区，将两区中所有存活对象复制到To区中并情况Eden区与From区，From与To区域互换。
3. 之后触发MinorGC会在To区与From区交替存储存活对象（若交替过程中To区域容量不足时也会借助老年代空间）。
4. 当有些对象达到存活阈值时，就会将该对象复制到老年代中。
5. 老年代满时会虚拟机会决策触发MajorGC使用标记清除算法或标记整理算法清理老年代还是触发FullGC全量回收。