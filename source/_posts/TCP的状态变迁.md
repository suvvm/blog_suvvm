---
title: TCP的状态变迁
date: 2020-04-05 17:51:26
categories: 
- 理论归纳
tags:
- 计算机网络
mathjax: true
---

# TCP的状态变迁

## 链接建立

由三报文握手建立TCP连接。

### 服务器状态变迁

- CLOSED（关闭） $\rightarrow$ LISTEN（监听）

  服务器启动，由关闭状态转变为监听状态等待客户端发送建立连接请求

- LISTEN（监听）$\rightarrow$ SYN_SENT（同步请求发送）

  服务器若向其他主机发送建立连接请求这时就变为了客户端，状态转为同步请求发送态，之后流程与客户端同步请求发送态相同。

- LISTEN（监听）$\rightarrow$ SYN_RCVD（同步请求收到）

  服务器收到客户端发送的同步位 SYN = 1 确认位 ACK = 0 的建立连接请求报文段后由监听状态转变为同步请求收到状态，并向客户端回复一个同步位 SYN = 1 确认位ACK = 1 的报文段。

- SYN_RCVD（同步请求收到）$\rightarrow$ FIN_WAIT_1（关闭等待初态）

  若服务器在等待ACK=1的确认报文段时可直接发送释放链接的FIN位为1的报文段，直接按链接释放处理。

- SYN_RCVD（同步请求收到）$\rightarrow$ ESTABLISHED（建立）

  服务器收到客户端发送的ACK = 1的确认报文段，确认连接建立（不发送任何报文段）由同步请求收到状态转变为TCP连接建立状态

### 客户端状态变迁

- CLOSED（关闭） $\rightarrow$ SYN_SENT（同步请求发送）

  客户端主动发起连接，由关闭状态转变为同步请求发送状态，并向服务器发送同步位 SYN = 1 确认位ACK = 0 的建立连接请求报文段。

- SYN_SENT（同步请求发送）$\rightarrow$ 服务端SYN_RCVD（同步请求收到）

  可能会出现两端同时发送SYN=1 ACK=0 的建立连接请求，这样的话客户端将转为SYN_RCVD状态，之后的流程与服务端SYN_RCVD相同。

- SYN_SENT（同步请求发送）$\rightarrow$ ESTABLISHED（建立）

  客户端收到服务器发送的同步位 SYN = 1 确认位ACK = 1的回复报文段，此时客户端认为连接已建立并向服务器回复ACK = 1的确认报文段（该段可直接用于传输数据）

- SYN_SENT（同步请求发送）$\rightarrow$ CLOSED（关闭）

  客户端在收到服务器SYN=1 ACK=0 的建立连接请求之前请求应用程序被关闭，或者客户端长时间没有收到服务器建立连接请求时会关闭链接，进入关闭状态

## 数据传输

客户端与服务器都处在ESTABLISHED状态持续数据直到其中一方收到FIN连接关闭请求报文段。

## 链接释放

四次挥手释放链接。

### 关闭发起者（主动端）

关闭发起者既可以是服务器又可以是客户端。

- ESTABLISHED（建立）$\rightarrow$ FIN_WAIT_1（关闭等待状态初态）

  主动端者向被动端发送FIN = 1的链接释放报文段

- FIN_WAIT_1（关闭等待初态）$\rightarrow$ FIN_WAIT_2（半关闭）

  主动端收到被动端发送的确认位ACK = 1的报文段后，此时主动端等待被动段发送FIN = 1且ACK = 1的链接释放报文段。

- FIN_WAIT_1（关闭等待初态）$\rightarrow$ CLOSEING （同时关闭）

  主动端发送链接释放报文段后首先收到的不是ACK=1的回复报文，而是收到了同样FIN=1的释放报文段，这证明在主动端发起释放的同时被动端也发起了释放，这时两者都成为了主动端，两者将会向对方发送ACK=1的确认报文段，并都进入CLOSING同时关闭状态。

- FIN_WAIT_1（关闭等待初态）$\rightarrow$ TIME_WAIT（等待超时）

  若主动端发送链接释放报文段被被动端成功接收，被动端也成功依次发送了ACK=1的回复报文段与FIN=1 ACK=1的释放报文段，但是ACK=1的回复报文段在传输过程中丢失，并没有被主动端接收到，主动端在FIN_WAIT_1直接收到了被动端发送的FIN=1 ACK=1释放报文段，此种情况下ACK=1的回复报文段丢失并不影响链接的释放，主动端将直接向被动端发送ACK=1的报文段并进入TIME_WAIT等待超时状态。

- FIN_WAIT_2（半关闭）$\rightarrow$ TIME_WAIT（等待超时）

  主动端在半关闭状态成功收到服务端发动的FIN=1 ACK=1的释放报文段，主动端将向被动端发送ACK=1的报文段并进入TIME_WAIT等待超时状态。

- CLOSEING （同时关闭）$\rightarrow$ TIME_WAIT（等待超时）

  两个主动端在同时关闭状态收到ACK=1的回复报文段将直接进入TIME_WAIT等待超时状态。

- TIME_WAIT（等待超时）$\rightarrow$ CLOSED（关闭）

  主动端等待两个最大报文生存周期（MSL）后关闭。
  
  原因是若主动方立刻关闭连接可能会出现一下情况
  
  - 主动端发送的ACK丢失，被动端进行FIN重传，若主动端已关闭则被动端无法收到主动端确认报文段，一直处于LAST_ACK状态无法关闭
  - 若被动端在关闭后立刻重新发起了连接请求，又碰巧使用了同一个端口，这时网络中可能有上一次连接延迟却依旧存活的报文段，若此报文段突然抵达服务端，将被认为是新连接发送的报文，等待2MSL可以确保此时网络中的所有本次连接的报文全部消失。

### 关闭接收者（被动端）

- ESTABLISHED（建立）$\rightarrow$ CLOSE_WAIT（关闭等待）

  被动端收到主动端发送的FIN = 1的链接释放报文段，向主动端发送ACK=1的回复报文段并进入关闭等待状态。

- CLOSE_WAIT（关闭等待状态）$\rightarrow$ LAST_ACK（最终回复）

  被动端向主动端发送FIN=1 ACK=1释放报文段，并等待主动端发送ACK=1的回复报文段

- LAST_ACK（最终回复）$\rightarrow$ CLOSED（关闭）

  被动端收到主动端ACK=1的回复后关闭

## TCP状态图

![img](TCP的状态变迁\TCP状态图.svg)