---
title: 矩阵连乘问题(DP)原理分析
date: 2019-11-06 22:08:46
categories: 
- 算法相关
tags:
- 动态规划（DP）
mathjax: true
---

# 矩阵连乘问题（DP）原理分析

## 问题描述

给定n个可乘的数字矩阵 $A_1, A_2,..., A_n $，矩阵 $A_i $ 的规模为 $p_{i-1}\times p_i $ 求给定矩阵连乘的最优计算次序，使得计算乘积 $A_1\times A_2 \times ... \times A_n $ 所需执行的数乘次数最少.

## 矩阵乘法规则
$C=A\times B$ ，如果A为p行r列的矩阵，B为r行q列的矩阵，则根据矩阵乘法规则，A与B相乘后得到的矩阵C将是p行q列的矩阵，对于结果矩阵C中任意元素 $C_{ij}: C_{ij}= \sum {r \atop k=1} a_{ik}b_{kj}$ 即：一个元素 $C_{ij}$ 需要做r次乘法，所以若想要获得C中所有元素则需要进行 $p \times q \times r$次乘法。

由于矩阵乘法满足乘法结合律，所以当n个数字矩阵连乘时可以任意更换计算次序，随着计算次序的改变，所需计算的总乘法次数也会跟着改变，具体情况看下图。

![img](计算次序1.png)

![img](计算次序2.png)

现在要做的便是设计一种算法，可以求得一种计算次序使得总乘法次数最小。

## 解法分析
假设 $A_1\times A_2 \times ... \times A_n$ 的最优计算次序会在$A_k$时断开（只是打个比方，就像上方图计算 $A_1 \times A_2 \times A_3 \times A_4$ 时在 $A_1$ 处断开成为 $A_1与A_2 \times (A_3\times A_4)$ 一样）这时对最优计算次序的计算也会断开成为两个子问题 
$$
\left\{ \begin{aligned} 子问题1 & = & 求A_1\times A_2 \times ... \times A_k 的最优计算次序\\ 子问题2 & = & 求A_{k+1}\times A_{k+2} \times ... \times A_n 的最优计算次序\end{aligned} \right. 
$$ 

因为原问题是两子问题相乘，所以原问题的答案便是俩个子问题的答案加上最后一次两子问题产生的矩阵相乘所需要的乘法次数。根据上方列出的矩阵乘法计算规则 
$$
最后一次需要乘法次数= \\ 子问题1矩阵的行数 \\ \times 子问题2矩阵的列数 \\ \times 计算结果矩阵中一个元素所需的乘法次数
$$
而
$$
计算结果矩阵中一个元素所需的乘法次数=子问题1矩阵的列数=子问题2矩阵的行数
$$

这里我们把 $m[i][j]$ 记为最优计算次序下计算 $A_i \times A_{i+1} \times ... \times A_j$ 所需的乘法次数（最少乘法次数）

根据上述假设，我们依旧假设 $A_i \times A_{i+1} \times ... \times A_j$ 的最优计算次序会在 $A_k$ 时断开，这时的两个子问题便是 
$$  \left\{ \begin{aligned} 子问题1 & = & 求A_i\times A_{i+1} \times ... \times A_k 的最优计算次序m[i][k]\\ 子问题2 & = & 求A_{k+1}\times A_{k+2} \times ... \times A_j 的最优计算次序m[k+1][j]\end{aligned} \right. $$
根据上次假设总结出的公式我们便可以得到 
$$m[i][j]=m[i][k]+m[k+1][j]+最后一次需要乘法次数(子问题1矩阵\times 子问题2矩阵)$$

由于在矩阵连乘中，前一个矩阵的列数与后一个矩阵的行数相同，所以这里我们把所有矩阵的行与列属性记录在一个一维数组p中 $P_0$ 表示第一个矩阵的行数 $p_1$ 表示第一个矩阵的列数与第二个矩阵的行数，以此类推 $p_{n-1}$ 代表第n-1个矩阵的列数与第n个矩阵的行​数。

$$
最后一次所需乘法= \\ 子问题1矩阵的行数（等于A_i的行数） \\ \times 子问题2矩阵的列数（等于A_j的列数） \\ \times 计算结果矩阵中一个元素所需的乘法次数（等于子问题2矩阵的行数等于A_k的列数）\\=p_{i-1} \times p_j \times p_k
$$

这样便得到了动态规划算法最核心的动态转移方程
$$
m[i][j]=\left\{ \begin{aligned} 0(i = j )\\ m[i][k]+m[k+1][j]+p_{i-1} \times p_j \times p_k(i < j)\end{aligned} \right.
$$
有了它便可以去写代码了。