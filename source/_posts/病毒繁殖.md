---
title: 病毒繁殖
date: 2019-11-10 19:02:02
tags:
---

【问题描述】  

 　A学校的实验室新研制出了一种十分厉害的病毒。由于这种病毒太难以人工制造了，所以专家们在一开始只做出了一个这样的病毒。 

 　这个病毒被植入了特殊的微型芯片，使其可以具有一些可编程的特殊性能。最重要的一个性能就是，专家们可以自行设定病毒的分裂能力 K，假如现在有x 个病毒，下一个分裂周期将会有 Kx个一模一样的病毒。你作为该实验室的数据分析员，需要统计出在分裂到第N个周期前，一共有多少个病毒单体进行了分裂。一开始时总是只有一个病毒，这个局面算作第一个周期。由于答案可能很大，专家们只需要你告诉他们对给定的P取模后的答案。


 【输入格式】  

 　一行三个整数，依次是K, N, P。

 【输出格式】  

 　一行一个整数，你的答案（对P取模） 。

 【输入样例】  

 【样例1】

```
 5 3 7
```

 【样例2】

```
 2 6 23
```


 【输出样例】  

 【样例1】

```
6
```

 【样例2】

```
8
```


 【样例解释】  

 　样例一解释：第一个周期有 1 个病毒，产生了一次分裂。第二个周期有 $1 \times 5=5$ 个病毒， 这五个病毒都会分裂。 所以第三个周期前一共进行了1+5等于 6 次分裂。答案即为6 mod 7 = 6。

 【数据范围】  
$$
 1 < N < 10^{18}\\
 1 < K , P < 2^{31}
$$

本题就是求$ 1 + K + K^2 + …… + K^N $，对于这个问题可以将其拆分求出$
 1 + K + K^2 + …… + K^{ { \frac N2} - 1} $
再将其乘以$ K^{\frac N2} $即可得到$ K^{ \frac N2} + K^{ { \frac N2} + 1 } + …… + K^N $，之后将前面两式相加即可得到答案。递归解决即可，幂运算调用快速幂取模即可。
（关于快速幂取模可以去本人博客[https://www.suvvm.work/tags/快速幂/](https://www.suvvm.work/tags/快速幂/)上去翻）



```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
/*******************************************************
*
* FunctionName: power
* Description: 快速幂取模
* Parameter:
*   @a  底数
*   @b  指数
*   @mod模数
* Return:
*   返回幂运算取模后的结果
**********************************************************/
LL power(int a, int b, int mod){    //快速幂
    LL ans = 1;
    while(b){
        if(b & 1){  //从b的二进制末位开始判断
            ans = ans * a % mod;  //如果为1更新取模后的答案
        }
        a = a * a % mod;    //更新底数取模
        b >>= 1;    //b右移一位
    }
    return ans;
}
/*******************************************************
*
* FunctionName: solve
* Description: 分治解决n个周期前分裂的的细胞单体个数
* Parameter:
*   @k  分裂能力
*   @n  分裂周期次数
*   @p  模数
* Return:
*   返回n个周期前分裂的的细胞单体个数取模后的结果
**********************************************************/
LL solve(int k, int n, int p) {
    if(!n)  // 0次分裂只有一个初始病毒
        return 1;
    if(n & 1)   // 奇数次分裂
        return (1 + power(k, n/2 + 1, p)) * solve(k, n/2, p) % p;
    else    // 偶数次分裂
        return (power(k, n/2, p) + (1 + power(k, n/2 +1, p)) * solve(k, n/2 - 1, p)) % p;
}
int main()
{
    ios::sync_with_stdio(false);
    int k, n, p;
    cin >> k >> n >> p;
    n--; // 以第0次分裂为起始
    if(!n)
        cout << 0 << endl;
    else if(n == 1)
        cout << 1 << endl;
    else    // 第n周期前，没有进行第n周期
        cout << solve(k, --n, p) << endl;
    return 0;
}

```

