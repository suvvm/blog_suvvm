---
title: 软件工程导论
date: 2020-01-05 18:33:59
categories: 
- 理论归纳
tags:
- 软件工程导论
mathjax: true
---

[TOC]

# 软件工程导论

## 软件工程学概述

### 什么是软件

计算机程序、数据以及各种文档的集合

### 软件工程三要素

- 方法
- 工具
- 过程

### 软件危机(选择)

#### 软件危机介绍

在计算机的开发和维护过程中所遇到的一系列严重问题

#### 软件危机的表现

- 对开发成本和进度估计常常很不准确
- 用户对“已完成的”软件系统不满意的现象经常发生
- 软件产品质量往往靠不住
- 软件常常不可维护
- 软件通常没有适当的文档资料
- 软件成本在计算机系统中所占比例逐年上升
- 软件开发生产率提高的速度远远跟不上计算机应用的啤机及深入的趋势

#### 软件危机的产生原因

- 与软件本身特点有关
- 与开发和维护不正确有关

#### 消除软件危机的途径

- 对计算机软件有正确的认识
- 充分认识协同配合的重要性
- 推广使用在实践中总结出来的开发软件的成功方法和技术，并探索研究更有效的方法和技术
- 使用更好的开发工具

### 工程化原理开发（软件生存周期）

#### 必要性（优点）

- 有利于软件开发工程的组织和管理
- 降低了整个软件开发过程的困难程度
- 对每个阶段都可选用最优的管理方法
- 保证软件质量，提高生产效率

#### 原则

- 各阶段任务应尽可能相互独立

- 同一阶段任务性质尽可能相同

#### 软件8个生存周期

- 软件定义
  - 问题定义
  - 可行性研究
  - 需求分析
- 软件开发
  - 软件设计
  - 程序编码
  - 软件测试
- 软件维护
  - 运行维护

## 软件过程

为了获得高质量软件所需完成的一系列任务的框架，规定了完成各项任务的工作步骤

为了开发出客户需要的软件，什么人who、在什么时候when、做什么what、怎样做how以实现某一个特定的具体目标

#### 瀑布模型（必考）

瀑布模型（线性模型）一直是唯一被广泛采用的生命周期模型，现在它仍是软件工程中应用的最为广泛的过程模型

![img](软件工程导论\瀑布模型.JPG)

##### 特点

- 阶段间具有顺序性和依赖性

  - 必须等待前一阶段工作完成后才能开始后一阶段工作
  - 前一阶段的输出文档就是后一阶段的输入文档，只有前一阶段的输出文档正确，后一阶段的工作才能获得正确结果

- 推迟实现的观点

  分析与设计阶段主要考虑目标系统的逻辑模型，不涉及物理实现

- 质量保证的观点

  为了保证软件质量每个阶段都要坚持

  - 奥力给！！！（大雾）
  - 每个阶段都必须完成规定的文档，没有交出合格文档就是没有完成任务
  - 每个阶段结束前都要对完成的文档进行评审，以便尽早发生问题并改正

##### 优点

- 可强迫开发人员采用规范方法
- 严格规定了每个阶段必须提交的文档
- 要求每个阶段交出的所有产品都必须经过质量保证小组的仔细检验

##### 缺点

- 几乎完全依赖于书面规格说明，很可能导致最终开发出的软件产品不能真正满足用户的需要（需求规格说明与用户需求之间有差异）
- 瀑布模型只适用于项目开始时需求已确定的情况

#### 快速原型

快速建立起来的可以在计算机上运行的程序，完成的功能往往是最终产品能完成的功能的一个子集（实现核心功能的工作机）

![img](软件工程导论\快速原型.JPG)

- 原型系统已经与用户交互而得到验证，据此产生的规格说明文档正确的描述了用户需求，因此，在开发过程后续阶段不会因为发现规格说明文档的错误而进行较大的返工
- 开发人员通过建立原型系统已经学到了许多东西，因此在设计和编码阶段发生错误的可能性也比较小，减少了后续阶段需要改正前面阶段所犯错误的可能性。

#### 增量模型（渐增模型）

把软件产品作为一系列的增量构件来设计、编码、集成和测试。每个构件由多个相互作用的模块构成，并且能够完成特定的功能，使用增量模型时，第一构件往往实现软件的基本需求，提供最核心的功能

![img](软件工程导论\增量模型.JPG)

##### 优点

- 能在较短时间内向用户提交可完成部分工作的产品
- 逐步增加产品功能可以使用户有较充裕的时间学习和适应新产品，从而减少一个全新的软件可能给客户组织带来的冲击

##### 困难

- 在把每个新的增量构建集成到现有软件体系结构中时，必须不破坏原来已经开发出的产品
- 必须把软件的体系结构设计的便于进行扩充，向现有产品加入新构件的过程必须简单方便，软件体系结构必须是开放的。

#### 螺旋模型（唯一有风险分析）

使用原型及其他方法来尽量降低风险。理解这种模型的一个简便方法，是把它看作在每个阶段之前都增加风险分析过程的快速原型。

![img](软件工程导论\简单螺旋模型.JPG)

![img](软件工程导论\完整的螺旋模型.JPG)

#### 喷泉模型

“喷泉”体现了面向对象软件开发过程迭代和无缝的特征，迭代是软件开发过程中普遍存在的一种内在属性，用面向对象方法开发软件时，工作重点应该放在生命周期中的分析阶段。

![img](软件工程导论\喷泉模型.JPG)

## 问题定义

确定要解决的问题是什么

通过 客户访问调查，写出问题性质工程目标工程规模 应得到客户确认。

## 可行性研究

### 任务

不是解决问题，而是确定问题是否值得解决

### 4个方面

- 技术可行性
- 经济可行性
- 操作可行性
- 法律可行性

### 可行性分析研究过程

- 复查系统规模和目标
- 研究目前正在使用的系统
- 导出新系统的高层逻辑模型
- 进一步定义问题
- 导出评价供选择的解法
- 推荐行动方针
- 草拟开发计划书
- 写文档提交审查

### 系统流程图（业务流程图）

概括地描绘物理系统的传统工具

用图形符号以黑盒子形式描绘组成系统的每个部件（程序、文档、数据库、人工过程）

是一种**物理数据流图**不是程序流程图

#### 符号

利用符号可以把广义的输入输出操作具体化为读写存储在特殊设备上的文件（或数据库），把抽象处理具体化为特定的程序或手工操作

![img](软件工程导论\系统流程图.JPG)

![img](软件工程导论\系统流程图2.JPG)

#### 例子

装配厂有一座存放零件的仓库，仓库中现有的各种零件的数量以及每种零件的库存量临界值等数据记录在库存清单主文件中。仓库中零件数量变化时，应该及时修改库存清单主文件，如果那种零件的库存少于它的库存临界值，应该报告给采购部门，每天向采购部门送一次订货报告。

- 使用一台小型计算机处理更新库存清单主文件和产生订货报告的任务
- 零件库存量的每一次变化称为一个事务，由放在仓库中的CRT终端输入到计算机中
- 系统中的库存清单程序对事务进行处理，更新存储在磁盘上的库存清单文件，并把必要的订货信息写在磁带上
- 每天由报告生成程序读一次磁带，并打印出订货报告

![img](软件工程导论\系统流程图3.JPG)

### 成本/效益分析

#### 四个方面

- 货币的时间价值

- 投资回收期

  累计的经济效益等于最初投资所需要的时间，也就是达到估计开发总成本加上运行维护费用所需要的时间

- 纯收入

  累计经济效益（折合成现在值）－ 投资额

- 投资回收率

  年经营净现金流量或年均经营净现金流量 / 原始投资额

通常用利率的形式表示货币的时间价值。假设年利率为i， 如果现在存入P元，则n年后可以得到的钱数为

$F = P(1+i)^n$

这也就是P元钱在n年后的价值

反过来，现在的价值

$P = \frac F{(1+i)^n}$

## 需求分析

需求分析是软件定义时期的最后一个阶段，它的基本任务是准确地回答“系统必须做什么”这个问题。

### 综合要求

- 功能需求
- 性能需求
- 可靠性和可用性需求
- 出错处理需求
- 接口需求
- 约束
- 逆向需求
- 将来可能提出的要求

与用户沟通获取需求的方法：访谈

### 结构化分析方法（SA）

面向数据流的需求分析方法

#### 数据流图DFD

是一种功能模型

数据流图是一种图形化技术，它描绘信息流和数据从输入移动到输出的过程中所经受的变换



##### 符号

![img](软件工程导论\数据流图.JPG)

##### 多个数据流之间的关系

![img](软件工程导论\数据流图2.JPG)



##### 数据流图的四个元素

- 数据流

  数据在系统内传播，由一组固定的数据项组成。除了与数据存储之间的数据流不用命名外，数据流应该用名词或名词短语命名

- 加工

  也成为数据处理，它对数据流进行某些操作或变换。每个加工也要有名字，通常是动词短语，在分层的数据流图中加工还要有编号。

- 数据存储

  暂时保存的数据，可以是数据库文件或以任何形式的数据组织，流向数据存储的数据流可理解为写入文件或查询文件，从数据存储流出的数据可理解为从文件读数据或得到的查询结果。

- 数据源点和终点

  统称为外部实体，指系统外部环境中的实体（包括人员、组织、或其他系统）是数据的始发点和终止点，是系统与外部环境的接口

##### 画图方法

- 确定外部实体及输入、输出数据流
- 确定分解顶层的加工
- 确定使用的文件
- 用数据流将各部分链接起来，形成数据封闭
- 如果需要，继续分解加工直至达到“基本加工”

##### 环境图

也称顶层数据流图（0层数据流图），仅包括一个数据处理过程，也是要开发的目标系统。

环境图的作用是确定系统在其环境中的位置，通过确定系统输入和输出与外部实体的关系确定其边界。

##### 分解原则

分解到不能再分

自然性：概念上合理清晰

均匀性：理想的分解是将一个问题分解成大小均匀的几个部分

分解度：每个加工分解一般不超过7 +- 2个子加工，分解到基本加工为止（不能再分）

#### 数据字典

##### 概念

数据字典是关于数据的信息的集合，也就是对数据流图中包含的所有元素的定义的集合。

数据字典可以把不同的需求文档和分析模型紧密结合在一起，如果所有的开发人员在数据字典上取得一致意见，那么就可以缓和集成性问题。为了避免冗余和不一致性，应该在项目中创建一个独立的数据字典，而不是在每个需求出现的地方定义每一个数据项

##### 用途

- 作为分析阶段的工具
- 包含每个元素的控制信息
- 是开发数据库的第一步

##### 内容

![img](软件工程导论\数据字典.JPG)

对数据流图中包含的所有元素的定义的集合构成了数据词典。 数据词典和数据流图共同构成系统的逻辑模型

- 数据项也称数据元素，是数据的最小单位。

  数据项名称及其编号、别名、取值范围和取值含义、备注。

  ![img](软件工程导论\数据字典数据项.JPG)

- 数据结构

  一个数据结构由若干个数据项或者由若干个数据结构组成——它把关 系“密切”的数据组合在一起。

  名称及其编号，数据结构的组成。 若是一个简单的数据结构，只列出数据项； 若嵌套了数据结构，只列出数据结构的名称

  ![img](软件工程导论\数据字典数据结构.JPG)

- 数据流

  在数据流图中，数据以数据流为单位进行传输

  数据流名称及其编号、别名 数据流的来源（或是外部实体或是加工或是数据存储） 数据流的去向（或是外部实体或是加工或是数据存储） 数据流的组成（可以包含若干个数据结构，若只有一个数据结构， 就不需要专门定义）。

  ![img](软件工程导论\数据字典数据流.JPG)

- 数据存储

  保留或保存数据的地方

  数据存储名称及其编号、数据存储的组成（包含的数据项或数据结 构）、组织方式

  ![img](软件工程导论\数据字典数据存储.JPG)

- 加工逻辑

  名称及其编号、加工逻辑的输入和输出、加工逻辑的说明（对加 工逻辑的功能做明确的描述。

  ![img](软件工程导论\数据字典加工逻辑.JPG)

- 外部实体

  人机界面

  外部实体的名称、编号及外部实体的简述，与外部实体有关的数据流

  ![img](软件工程导论\数据字典外部实体.JPG)

#### 判定树（决策树）

用于描述分类过程的二叉树

一图书销售系统，其中一加工为“优惠处理” ，条件是：顾客的 营业额大于1000元，同时必须信誉好；或者虽然信誉不好，但是20年以上 的老主顾。

![img](软件工程导论\判定树.JPG)

例题

某数据流图中有一个“确定保险类别”的加工，指的 是申请汽车驾驶保险时，要根据申请者的情况确定不同的 保险类别。加工逻辑为：如果申请者的年龄在21岁以下， 要额外收费；如果申请者是21岁以上并是26岁以下的女性 ，适用于A类保险；如果申请者是26岁以下的已婚男性， 或者是26岁以上的男性，适用于B类保险；如果申请者是 21岁以下的女性或是26岁以下的单身男性，适用于C类保 险。除此之外的其他申请者都适用于A类保险。 画出相应的判定树。

![img](软件工程导论\判定树例题.JPG)

#### 判定表

判定表是一种二维的表格，常用于较复杂的组合条件（与结构化语 言比较），通常由四部分组成：条件、行动方案、状态、选择规则

![img](软件工程导论\判定表1.JPG)

优化后

![img](软件工程导论\判定表2.JPG)

判定表的简化

![img](软件工程导论\判定表的简化.JPG)

### 状态图(状态转换图)

状态转换图通过描绘系统的状态及引起系统状态转换的事件，来表示系统的行为。指明了作为特定事件的结果系统将做那些动作。

#### 状态

状态是任何可以被观察到的系统行为模式，一个状态代表系统的一种行为模式。状态图指明了作为特定事件的结果系统将做那些动作。

在状态图中定义的状态主要有：

- 初态（初始状态）
- 终态（最终状态）
- 中间态

只能有一个初态，终态可以有0至多个。

#### 符号

初态用实心圆表示，终态用牛眼图形表示，中间态用圆角矩形表示

![img](软件工程导论\状态图符号.JPG)



#### 状态转换

- 两个状态之间带箭头的连线称为状态转换

- 状态变迁通常由事件触发，应在表示状态转换的箭头线上标出触发转换的事件表达式。

  事件表达式：事件说明[守卫条件]/动作表达式

- 如果箭头线上未标明事件，则表示在源状态的内部活动执行完之后自动触发转换

![img](软件工程导论\状态图.JPG)

#### 示例

电话系统状态图

![img](软件工程导论\电话状态图.png)

存款过程状态图

![img](软件工程导论\存款过程状态图.png)



### 软件需求规格说明书

软件需求规模说明是需求分析阶段得出的最主要的文档。

通常用自然语言完整、准确、具体地描述系统的数据要求、功能需求、性能需求、可靠性和可用性要求、出错处理需求、接口需求、约束、逆向需求以及将来可能提出的要求。



## 软件设计

### 总体设计（概要设计）

最关键步骤：确定软件体系结构

#### 总体设计的九大任务

- 设想供选择的方案
- 选取合理的方案
- 推荐最佳方案
- 功能分解
- 设计软件结构
- 设计数据库
- 制定测试计划
- 书写文档
- 审查和复审

#### 设计原理

##### 模块化

把程序划分成独立命名且可独立访问的模块，每个模块完成一个子功能，把这些模块集成构成一个整体，可以完成指定的功能满足用户的需求。

##### 结构图

精确表达模块结构的图形表示工具

- 调用关系和接口：在结构图中两个模块之间用单向箭头连接
- 模块之间的信息传递：当一个模块调用另一个模块时，调用模块把数据或控制信息传送给被调用的模块，以使被调用模块能够运行

![img](软件工程导论\结构图.JPG)

- 有条件调用在箭头尾部加菱形
- 反复调用加弧形

![img](软件工程导论\结构图2.JPG)

- 深度：表示从顶层模块到底层模块的层数
- 宽度：同一层次上的模块总数
- 扇出数：一个模块直接控制的下属模块数
- 扇入数：一个模块直接上属模块个数

![img](软件工程导论\结构图3.JPG)

- 选择调用：根据判断决定是否调用（空心菱形）

![img](软件工程导论\结构图4.JPG)

#### 耦合

耦合性指软件结构中模块连接的紧密程度，是模块间相互连接性的度量。耦合强度的大小是由模块间**接口的复杂程度**决定的。

##### 耦合的类型

- 内容耦合 高耦合

  - 一个模块直接访问另一模块的内部数据
  - 一个模块不通过正常入口转到另一模块内部
  - 一个模块由多个入口
  - 两个模块由部分代码重迭

  高级语言中不允许出现，但汇编语言中可能出现

- 公共耦合

  若干模块访问一个公共的数据环境（全局数据结构、共享的通信区、内存的公共覆盖区）耦合的复杂度随耦合模块的数量增加而增加

  - 松散公共耦合

    模块同时只对公共数据环境进行读或写一种操作（目前使用较多的低耦合方式）

  - 紧密公共耦合

    若干模块对公共数据环境同时读和写

    使公共数据区的变化影响所有公共耦合模块，严重影响模块可靠性和可适应性，降低软件可读写（强耦合）

  问题

  - 无法控制各个模块对公共数据的存取，严重影响软件模块的可靠性和适应性
  - 使软件可维护性变差
  - 降低软件的可理解性

  只有共享数据过多，传参不方便时使用公共耦合

- 外部耦合 

  一组模块都通过访问同一全局**简单变量**，而不是通过传参传递该信息。

- 控制耦合 中耦合

  一个模块传递给另一个模块的信息是用于控制该模块内部的控制信号，对被控制模块的任何修改都会影响到控制模块

- 标记耦合 

  一个模块传给另一个模块的参数是一个复合的数据结构（如高级语言的数组名、记录名，其实传递的是地址）会使某些本来无关的模块产生相互依赖性

- 数据耦合 低耦合

  一个模块传给另一个模块的参数是单个的数据项或单个数据项组成的数组，模块间传递的是简单数据值，相当于高级语言中的值传递

- 非直接耦合 低耦合

  两个模块间没有直接的关系，它们分别从属于不同模块的控制与调用，之间不传递任何信息，这种耦合程度最弱，模块独立性最高

![img](软件工程导论\耦合性.png)

尽量使用数据耦合，少用控制耦合和特征耦合（把整个数据结构作为参数传递而被调用的模块只需要 使用其中一部分数据元素），限制公 共环境耦合的范围，完全不用内容耦合

#### 内聚

内聚性表示一个模块内部各个元素（数据、处理）之间联系的紧密程度。它是信息隐蔽和局部化概念的自然扩展，是从功能的角度来度量模块间的联系。块内联系愈紧，即内聚性愈高，模块独立性愈好。

##### 内聚的类型

- 偶然内聚（巧合） 低内聚

  为了节约空间，将毫无关系或联系不多的各元素放在一个模块中。模块元素关系松散，不易理解，不易修改

- 逻辑内聚 低内聚

  将几个逻辑上相似的功能放在一个模块中，使用时由调用模块传递的参数确定执行的功能。由于由传递控制参数，影响了模块的内聚性

- 时间内聚（经典内聚） 低内聚

  把需要同时执行的成分放在一个模块中。如初始化、终止操作这一类内部结构比较简单的模块。由于判定较少，所以比逻辑内聚高，但由于内含多个功能，修改和维护困难

- 过程内聚 中内聚

  一个模块内的除了元素是相关的，而且必须以特定的次序执行。一个模块内有多个功能成分。

- 通信内聚 中内聚

  模块中的成分引用共同的输入数据，或者产生相同的输出数据，则称为通信内聚。

- 顺序内聚 高内聚

  一个模块内的处理元素都密切相关于同一功能，模块中的某个成分的输出是另一成分的输入。由于这类模块是按数据执行顺序，模块的一部分依赖于另一部分，因此具有较好的内聚性。

- 功能内聚 高内聚

  一个模块仅包括完成某一具体功能所必须的所有部分。模块的所有成分都是为完成该功能而协同工作、紧密联系、不可分割的。

  如 求平方根、判断素数、求解一元二次方程、计算利息等。

#### 启发设计规则

##### 改进软件结构提高模块独立性

设计出初步结构后应审查分析，通过模块分解或合并，力求降低耦合提高内聚

##### 模块规模应该适中

模块规模不应过大（60行）

##### 深度、宽度、扇出、扇入都应适当

##### 模块的作用域应该在控制域内

作用域：受该模块内一个判定影响的所有模块的集合

控制域：模块本身以及所有直接或间接从属于它的模块的集合

![img](软件工程导论\作用范围与控制范围.JPG)

![img](软件工程导论\作用范围与控制范围2.JPG)

菱形代表判定所在模块，蓝色代表判定影响模块

d的设计最合理

##### 力争降低接口的复杂度

接口复杂是软件发生错误的主要原因之一，应使信息传递简单且和模块功能一致

##### 设计单入口单出口的模块

这条启发式规则警告不要出现内容耦合

##### 模块功能应该可以预测

模块功能应该可以预测，但也要防止模块功能过于局限

#### 面向数据流的设计方法（注意判断结构图类型）

把信息流映射成软件结构，信息流的类型决定了映射的方法

##### 信息流的两种类型

- 变换流

  信息沿输入通路进入系统，由外部形式变换为内部形式，进入系统的信息经过变换中心，经加工处理后再沿输出通路变换为外部形式离开软件系统

  ![img](软件工程导论\变换流.JPG)

  通过**变换分析**技术将中心变换型的数据流图（DFD）变为结构图（SC），得到的的SC图称为变换型系统结构图，相应于取得的数据、变换数据、给出数据，系统的结构体由**输入、中心变换和输出**三部分组成。

  ![img](软件工程导论\变换型系统结构图.JPG)

  **变换分析技术**

  - 确定主加工及逻辑输入输出
  - 进行一级分解，设计上层模块
  - 进行二级分解设计中下层模块
  - 进一步细化

- 事务流

  数据沿输入通路到达一个处理T，这个处理根据输入数据的类型在若干个动作序列中选出一个来执行

  ![img](软件工程导论\事务流.JPG)

  处理T称为数据中心

  - 接收输入数据
  - 分析每个事务以确定它的类型
  - 根据事务类型选择活动通路

  通过**事务分析**技术将中心变换型的数据流图（DFD）变为结构图（SC），得到的的SC图称为事务型系统结构图，事务中心模块按所接受的事务类型选择某一个事务处理模块执行，各个事务处理模块是并列的，依赖于一定的选择条件，分别完成不同的事务处理工作。

  ![img](软件工程导论\事务型系统结构图.JPG)

  **事务分析技术**

  - 确定流界
  - 进行一级分析，设计上层模块
  - 进行二级分解，设计中下层模块

### 详细设计

#### 根本目标

确定应该怎样具体地实现所要求的系统，任务不是具体地编写程序，而是要设计出程序的“蓝图”

详细设计的结果基本决定了最终程序代码的质量

#### 主要内容

- 结构程序设计
- 人机界面设计
- 过程设计的工具
- 面向数据结构的设计方法
- 程序复杂程度的定量度量

#### 结构程序设计

- 少用goto
- 代码块单入单出
- 使用顺序选择循环
- 自顶向下逐步求精

顺序、选择和循环

结构程序设计经典定义：一个程序的代码块仅由顺序选择和循环三种基本控制连接，且每个代码块只有一个入口和一个出口，则称这个程序是结构化的。

扩展的结构程序设计：在以上基础上允许 DO-CASE和DO-UNTIL

修正的结构程序设计：在以上基础上允许使用LEAVE（或BREAK）结构  

#### 人机界面设计

- 系统响应时间
- 用户帮助设施
- 出错信息处理
- 命令交互

#### 过程设计工具（三种图）

##### 程序流程图

![img](软件工程导论\程序流程图.png)

**缺点**

- 本质上不是逐步求精的好工具，诱使程序员过早的考虑程序的控制流程，而不去考虑全局结构
- 程序流程图中用箭头代表控制流，程序员不受任何约束，可以完全不顾结构程序设计的精神，随意转移控制
- 程序流程图不易表示数据结构

![img](软件工程导论\程序流程图实例.JPG)

##### 盒图（N-S图）

不允许违背结构程序设计精神的图形工具

**特点**

- 功能域（特定控制结构的作用域）明确
- 不可能任意转移控制
- 很容易确定局部和全程数据的作用域
- 很容易表现嵌套关系，也可以表示模块的层次结构![]

![img](软件工程导论\盒图.png)

**实例**

![img](软件工程导论\盒图实例1.JPG)

![img](软件工程导论\盒图实例2.JPG)

##### PAD图（问题分析图）

用二维树形结构的图来表示程序的控制流

![img](软件工程导论\PAD图.png)

**优点**

- 使用表示结构化控制的PAD符号设计出的程序必然是结构化程序
- PAD图所描绘的程序结构十分清晰
- PAD图表现程序逻辑，易读、易懂、易记
- 容易将PAD图转换为高级语言
- 既可用于表示程序逻辑，也可以用于描绘数据
- PAD图符号支持自顶向下、逐步求精方法的使用

##### 判定表

总体设计中有提到，判定表能够清晰地表示复杂的条件组合与应做的动作之间的对应关系

![img](软件工程导论\判定表详细设计.JPG)

##### 判定树

判定树是判定表的变种，它也能清晰的表示复杂的条件组合与应做的动作之间的对应关系

![img](软件工程导论\判定树详细设计.JPG)

##### 过程设计语言（PDL）

PDL也称为伪码，是用正文形式表示数据处理和处理过程的设计工具

**特点**

- 关键字固定语法，提供了结构化控制结构、数据说明和模块化的特点
- 自然语言自由语法，描述处理特点
- 数据说明的手段，包括简单的数据结构，也包含复杂的数据结构
- 模块定义和调用的技术，应提供各种接口描述模式。

**优点**

- 可作为注释之间插在源程序中间
- 可使用普通的正文编辑程序或文字处理系统完成书写工作
- 可自动由PDL生成代码

#### 面向数据结构的设计方法

##### Jacksion图

![img](软件工程导论\Jacksion顺序.JPG)

A由B、C、D三个元素顺序组成，每个元素只出现一次，顺序为B$\rightarrow$C$\rightarrow$D

![img](软件工程导论\Jacksion选择.JPG)

根据条件A决定是B、C或D中的某一个

![img](软件工程导论\Jacksion重复.JPG)

A由B出现N次组成

**Jackson法**

- 分析并确定输入输出属性和输出数据的逻辑结构，用Jackson图描绘这些数据结构

- 找出输入数据结构和输出数据结构中有对应关系的数据单元

- 用下述3条规则从描绘数据结构的Jackson图导出描绘程序 结构的Jackson图

  - 为每对有对应关系的数据单元，按照它们在数据结构图中的 层次在程序结构图的相应层次画一个处理框
  - 根据输入数据结构中剩余的每个数据单元所处的层次，在程 序结构图的相应层次分别为它们画上对应的处理框
  - 根据输出数据结构中剩余的每个数据单元所处的层次，在程 序结构图的相应层次分别为它们画上对应的处理框

- 列出所有操作和条件，并把它们分配到程序结构图的适当位置

- 用伪码表示程序

  - ```c
    // 顺序结构
    A seq
        B
        C
        D
    A end
    ```

  - ```c
    // 选择结构
    A select cond1
        B
    A or cond2
        C
    A or cond3
        D
    A end
    ```

  - ```c
    // 重复结构
    A iter until(while) cond
        B
    A end
    ```

#### 程序复杂度定理度量

把程序的复杂程度乘以适当常数即可估算出软件中错误的数量以及软件开发需要用的工作量

定量度量的结果可以用来比较两个不同的设计或两个不同算法的优劣

程序的定量的复杂程度可以作为模块规模的精确限度

##### 计算环形复杂度的方法

- 流图中线性无关的区域数等于环形复杂度
- 流图G的环形复杂度V(G) = E - N + 2，E为边数，N为结点数
- G的环形复杂度V(G) = P + 1，P为流图中判定结点的数量

## 软件测试

软件生命周期的每个阶段不可避免地会产生错误，测试是对软件分析、设计、编码进行查错纠错的活动。软件测试是有**破坏性**的

### 测试目标

**根本目标**：尽可能多地发现并排除软件中潜藏的错误，最终把一个高质量的软件系统交给用户

**具体目标**

- 测试是为了发现程序中的错误而执行的过程
- 好的测试方案是极可能发现迄今为止尚未发现的错误的测试方案
- 成功的测试是发现了至今为止尚未发现的错误的测试

### 测试过程

- 单元测试：用设计的测试用例，测试模块是否正确实现了功能
- 集成测试：把通过单元测试的模块组装在一起，看能不能实现功能
- 系统测试：把经过确认的软件纳入实际运行环境与相应环境组合在一起进行测试，以检查软件是否能正确稳定地运行
- 验收测试：检查已经组装完成的软件是否能实现需求说明规定功能以及功能是否完整正确

#### 测试词汇

**测试工具**：测试用例 + 测试数据 + 预期结果 + 测试环境

**测试结束**：数据 + 期望结果 + 实际结果

### 测试方法

- 静态分析

  人工的、非形式化的方法对程序进行分析测试

- 动态测试

  选择适当的测试用例，执行程序

  - 黑盒测试
  - 白盒测试

#### 黑盒测试

不考虑程序内部结构与特性，只根据程序功能或程序的外部特性设计测试用例

##### 等价类

把被测对象的输入域分为有限个等价区段——“等价类”，以有针对性的等价类少量测试，代替漫无边际的、数量大的“穷尽”测试或随机测试。

**等价类划分**

- 有效等价类

  对于程序的规格说明是合理的、有意义的输入数据的集合。

- 无效等价类

  对于程序的规格说明是不合理、没有意义的输入数据集合。

**选择测试用例**

测试用例要尽量多覆盖有效等价类，每个无效等价类要有对应测试用例

**边界值分析法**

边界类型：下标、数据结构、循环、选择等的边界附近

使程序运行在边界附近的测试方案更容易暴露程序错误

一般选取刚好等于、稍小于和稍大于等价类边界值的数据作为测试数据

**错误推测法**

列举出程 序中可能有的错误和容易发生错误的特殊情况，并且根据它们选择测试方案

#### 白盒测试（结构测试）

分析程序的内部逻辑结构，根据适当的覆盖标准设计测试用例，对主要路径进行尽可能多的测试

##### 六个标准（弱到强）

- 语句覆盖：每条语句至少执行一次
- 判定覆盖：每个判定的每个分支至少执行一次
- 条件覆盖：每个判定的每个条件应取到各种可能的值
- 判断条件覆盖：同时满足判定覆盖和条件覆盖
- 条件组合覆盖：每个判定中各条件的每一种组合至少出现一次
- 路径覆盖：使程序中每一条可能的路径至少执行一次

一般以条件组合覆盖为主测试用例，然后补充部分用例以达到路径覆盖测试标准。

##### 基本路径测试

在程序控制流图的基础上通过分析构造的环路复杂性，导出基本可执行路径的集合。

设计出的测试用例保证在测试中程序的每一给可执行语句至少执行一次

- 先画控制流图

- 计算复杂度

  从程序的环路复杂性可导出程序基本路径集合中的独立路径条数，这是确定程序中每个可执行语句至少执行一次所必须的测试用例数目的上界

  计算区域时应包括图外部的范围。

- 写出基本路径

  ![img](软件工程导论\白盒基本路径.JPG)

- 设计测试用例

注意如果判断语句由多条语句复合而成，需要将其单独分开成为多个条件

## 软件维护

在软件已经交付使用之后，为了改正错误或满足新的需要而修改软件的过程

### 软件可靠性

#### 定义

程序在给定时间间隔内，按照规格说明书的规定成功运行的概率

#### 软件可用性

程序在给定时间点，按照规格说明书的规定，成功运行的概率

#### 平均无故障时间MTTF

##### 符号

$E_T$——测试之前程序中的错误总数

$I_T$——程序长度（机器指令总数）

$\tau$——测试（包括调试）时间

$E_d(\tau)$——在0至$\tau$期间发现的错误数

$E_c(\tau)$——在0至$\tau$期间改正的错误数

$MTTF=\frac{1}{K(\frac{E_T}{I_t}-\frac{E_c(\tau)}{I_T})}$

K的典型值是200

### 维护的四种类型

- 改正性维护
- 适应性维护
- 完善性维护
- 预防性维护

### 维护的过程

#### 维护过程的本质

修改和压缩了的软件定义和开发过程

- 维护组织

  ![img](软件工程导论\维护组织.JPG)

- 维护报告

  用标准化格式表达所有软件维护要求

- 维护的事件流

  不管维护类型如何都包括

  修改软件设计、复查、必要的代码修改、单元测试和集成测试(包括使用以前的测试方案的回归测试)、验收测试和复审

- 保护维护记录

- 评价维护活动

### 维护的副作用

- 修改代码的副作用

  可能引入新的错误

- 修改数据的副作用

  原有软件设计可能对这些数据不在适应从而产生错误

- 修改文档的副作用

  如果源代码的修改没有反映在设计文档或用户手册中，就会产生文档的副作用

### 软件的可维护性

- 可理解性
- 可测试性
- 可修改性
- 可移植性
- 可重用性

## 面向对象

### 基本特征

- 封装：隐藏对象的属性和实现细节，仅对外公开接口
- 继承：子类继承父类的特征和行为
- 多态：是指一个类实例（对象）的相同方法在不同情形有不同表现形式

## UML

### UML9种图

- 动态
  - 顺序图
  - 活动图
  - 协作图
  - 状态图
- 静态
  - 用例图
  - 类图
  - 对象图
  - 构件图
  - 部署图

#### 用例图（静态）

用于描述用例模型，包括参与者用例之间的关系

##### 关系

**关联** 

![img](软件工程导论\关联.png)

实线，参与者与用例之间的交互，表示通信（若带箭头可以表明发起者）

**包含**

![img](软件工程导论\包含.png)

带箭头虚线，指向被包含用例，包含用例是必须的



**扩展**

![img](软件工程导论\扩展.png)

带箭头虚线，指向被扩展用例，扩展用例是可选的

**泛化**

![img](软件工程导论\泛化.png)

空心三角实线，特殊方（子类）指向一般方（父类），就是继承的逆过程

用例和参与者：关联 

用例：包含（include）扩展（extend）  泛化

参与者： 继承（泛化的逆过程）

##### 实例

![img](软件工程导论\用例图.JPG)

#### 类图（静态）

描述了类与类之间的静态关系。

##### 关系

**泛化**

![img](软件工程导论\泛化.png)

空心三角实线，子类指向父类

**关联**

![img](软件工程导论\关联类图.png)

实线，两端写有对应关联方式，双向关联无箭头，单项关联有一个箭头

**实现**

![img](软件工程导论\类图实现.png)

空心三角+虚线，是整体与部分的关系，且部分可以离开整体而单独存在

**聚合**

![img](软件工程导论\类图聚合.png)

实线+空心菱形

**组合**

![img](软件工程导论\类图组合.png)

实心菱形+实线，是整体与部分的关系，但部分不能离开整体而单独存在

**依赖**

![img](软件工程导论\类图依赖.png)

带箭头虚线，指向被依赖的对象，一个类的实现需要另一个类的协助

##### 实例

![img](软件工程导论\类图.JPG)

#### 顺序图(交互图 动态)

- 表示用例中的行为顺序

- 展示对象之间的交互

- 顺序图重点在消息队列上
- 浏览顺序图的方法：从上到下查看对象间交互信息

##### 事务

**参与者**

![img](软件工程导论\顺序图参与者.png)

与系统，子系统或类发生交互的外部用户

**对象**

顺序图横轴是有关对象，矩形框+对象名+下划线

![img](软件工程导论\顺序图对象.png)

**生命线**

坐标轴纵向虚线表示对象在序列终点执行情况

![img](软件工程导论\顺序图生命线.png)

**消息符号**

消息用从一个对象的上面写到另一个对象生命线的箭头表示

![img](软件工程导论\顺序图消息.png)

##### 示例

![img](软件工程导论\顺序图.JPG)

#### 协作图（交互图 动态）

顺序图的变化形式，描述相互协作的对象之间的交互关系和连接关系

与顺序图的区别：顺序图侧重时间，但没有明确表示对象之间的关系

##### 示例

![img](软件工程导论\协作图.JPG)

#### 状态图(动态)

描述一个特定对象的所有可能的状态以及引起状态转换的事件

##### 事务

- 初态

  ![img](软件工程导论\初态.png)

- 终态

  ![img](软件工程导论\终态.png)

- 中间状态

  ![img](软件工程导论\中间态.png)

- 复合状态

- 消息

  ![img](软件工程导论\状态图消息.png)

##### 示例

![img](软件工程导论\支票状态图.JPG)

![img](软件工程导论\存款过程状态图.png)

![img](软件工程导论\电梯状态图.JPG)

#### 活动图（动态）

用来捕捉用例的活动，使用框图的方式显示动作及其结果

活动图是一种流图，描述了从活动到活动的流

是另一种描述交互的方式，描述采取何种动作，动作的结果是什么（动作改变状态），何时发生（动作序列），在何处发生（泳道）

##### 事务

**起点**

![img](软件工程导论\初态.png)

**终点**

![img](软件工程导论\终态.png)

**活动**

![img](软件工程导论\活动图活动.png)

动作的执行

**对象流**

![img](软件工程导论\活动图对象流.png)

活动之间交换的信息

**发送信号**

![img](软件工程导论\发送信号.png)

活动过程中发送的事件，触发另一伙的流程

**接收信号**

![img](软件工程导论\活动图接收信号.png)

活动过程中接收的事件，接收到信号的活动流程序开始执行

**泳道**

![img](软件工程导论\活动图泳道.png)

活动的负责者

##### 关系

**迁移**

![img](软件工程导论\活动图迁移.png)

活动的完成与新活动的开始

**分支**

![img](软件工程导论\活动图分支.png)

根据条件，控制执行方向

**分叉**

![img](软件工程导论\活动图分叉.png)

以下的活动可并发执行

**结合**

![img](软件工程导论\活动图结合.png)

以上的并发活动在此结合

##### 示例

![img](软件工程导论\活动图取款.JPG)

#### 构件图（静态）

描述构建之间的依赖关系，是面向对象思想的核体现

构建是逻辑交给中定义的概念和功能（如类、对象与关系），在物理架构中的实现

构件图中包含三种元素，构件、接口和关系，描述了系统各个构件终点依赖关系，构件接口以及调用关系，可以使用包来组织，使用注解与约束来解释和限定

##### 示例

![img](软件工程导论\构件图.JPG)



#### 部署图（配置图 静态）

描述处理器、设备和连接，显示系统硬件的物理拓扑结构及在此结构上执行的软件，每个系统只有一个部署图

部署图可以显示计算节点的拓扑结构和通信路径、节点上运行的软件以及软件包含的逻辑单元。

##### 部署图与对象图

部署图编写构件实例

构件图表现构件类型的定义

部署图偏向于描述构件在结点中运行时的状态，描述了构件运行的环境

构件图偏向于描述构件之间相互依赖支持的基本关系

##### 示例

![img](软件工程导论\部署图.JPG)

#### 对象图

类图变化而来，显示一组对象和他们之间的关系

![img](软件工程导论\对象图.JPG)