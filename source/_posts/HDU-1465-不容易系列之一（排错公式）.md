---
title: HDU 1465 不容易系列之一（排错公式）
date: 2018-11-23 15:07:04
categories: 
- 算法相关
tags:
- 排错公式
- HDU
---

大家常常感慨，要做好一件事情真的不容易，确实，失败比成功容易多了！ 
做好“一件”事情尚且不易，若想永远成功而总从不失败，那更是难上加难了，就像花钱总是比挣钱容易的道理一样。 
　　话虽这样说，我还是要告诉大家，要想失败到一定程度也是不容易的。比如，我高中的时候，就有一个神奇的女生，在英语考试的时候，竟然把40个单项选择题全部做错了！大家都学过概率论，应该知道出现这种情况的概率，所以至今我都觉得这是一件神奇的事情。如果套用一句经典的评语，我们可以这样总结：一个人做错一道选择题并不难，难的是全部做错，一个不对。 

　　不幸的是，这种小概率事件又发生了，而且就在我们身边： 
　　事情是这样的——HDU有个网名叫做8006的男性同学，结交网友无数，最近该同学玩起了浪漫，同时给n个网友每人写了一封信，这都没什么，要命的是，他竟然把所有的信都装错了信封！注意了，是全部装错哟！ 

　　现在的问题是：请大家帮可怜的8006同学计算一下，一共有多少种可能的错误方式呢？

Input

　　输入数据包含多个多个测试实例，每个测试实例占用一行，每行包含一个正整数n（1<n<=20），n表示8006的网友的人数。

Output

　　对于每行输入请输出可能的错误方式的数量，每个实例的输出占用一行。

Sample Input

```
2
3
```

Sample Output

```
1
2
```

解题思路：
　　本题有多组测试，每组测试给出网友人数n，要求输出信全装错的方式数量。

　　这是一个典型的错排问题

　　错排思路，设我们正在对第1封信进行操作，我们只需要将第1封信与后面任意一封信交换位置，设被交换的信为看，就可以满足第1封信错放的条件，共有n - 1种方法，这时对于第k封信，有两种可能性，1、将k放到位置1，对于除了1与k的其他n-2封信，又可以进行同样的操作。2、k不在位置1，那么现在还剩n-1封信n-1个信封，那么对这n-1封信又可以进行同样的操作。

　　我们只需开一个数组d，以d(n)记录n封信全放错的方法数量。

　　根据上面分析，可以得出d(n) = (n - 1) * [ d( n - 1) + d( n - 2)]。

　　这就是错排公式。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int maxn = 25;
LL d[maxn];
int main()
{
    int n;
    memset(d, 0, sizeof(d));    //初始化所有全放错数量为0
    d[2] = 1;   //两封信只有一冲全放错方法
    for(int i = 3; i <= maxn; i++){
        d[i] = (i - 1) *(d[i - 1] + d[i - 2]);
    }
    //根据错排公式计算25封信以内所有答案打表
    while(scanf("%d", &n) != EOF){  //输入网友数量
        printf("%lld\n", d[n]); //输出答案
    }
    return 0;
}
```

