---
title: HDU 2191 悼念512汶川大地震遇难同胞
date: 2018-11-07 23:50:28
categories: 
- 算法相关
tags:
- 动态规划（DP）
- HDU
---
<meta name="referrer" content="no-referrer"/>
急！灾区的食物依然短缺！ 
　　为了挽救灾区同胞的生命，心系灾区同胞的你准备自己采购一些粮食支援灾区，现在假设你一共有资金n元，而市场有m种大米，每种大米都是袋装产品，其价格不等，并且只能整袋购买。 
请问：你用有限的资金最多能采购多少公斤粮食呢？ 

后记： 
　　人生是一个充满了变数的生命过程，天灾、人祸、病痛是我们生命历程中不可预知的威胁。 
　　月有阴晴圆缺，人有旦夕祸福，未来对于我们而言是一个未知数。那么，我们要做的就应该是珍惜现在，感恩生活—— 
　　感谢父母，他们给予我们生命，抚养我们成人； 
　　感谢老师，他们授给我们知识，教我们做人 
　　感谢朋友，他们让我们感受到世界的温暖； 
　　感谢对手，他们令我们不断进取、努力。 
　　同样，我们也要感谢痛苦与艰辛带给我们的财富～ 

 ![img](http://acm.hdu.edu.cn/data/images/C132-1006-2.JPG) 

Input

　　输入数据首先包含一个正整数C，表示有C组测试用例，每组测试用例的第一行是两个整数n和m(1<=n<=100, 1<=m<=100),分别表示经费的金额和大米的种类，然后是m行数据，每行包含3个数p，h和c(1<=p<=20,1<=h<=200,1<=c<=20)，分别表示每袋的价格、每袋的重量以及对应种类大米的袋数。Output对于每组测试数据，请输出能够购买大米的最多重量，你可以假设经费买不光所有的大米，并且经费你可以不用完。每个实例的输出占一行。

Sample Input

```
1
8 2
2 100 4
4 100 2
```

Sample Output

```
400
```

解题思路：
　　本题给出测试数量，每组测试给出现有资金数n，大米种类m，之后跟随m行为每种大米的具体信息，包括大米价格，每袋重量，库存袋数。只能购买整袋，可以购买的最大重量。

　　本题是标准的多重背包问题，背包的容量位资金数量，背包内容物价值为大米的重量，本题数据范围比较小，可以直接将多重背包问题转化为0 - 1背包问题（无需优化即可AC）。

　　基本思路便是将每种大米拆分为单袋大米。令dp[i][j]表示如果手中资金为 j 则恰好购买前i袋大米能获得最大重量。

　　对于第i袋大米，有买或不买两种选择方案。

　　1、买第i袋大米，问题转化为求手中资金为（ j - 第 i 件大米价格 ）在之前i - 1袋大米中购买最大重量的问题。

　　2、不买第i袋大米，问题转化为手中资金为 j 时在之前i - 1袋大米中购买最大重量的问题。

　　只需要在这两种情况中选择重量最大的情况即可。

　　状态转移方程：dp[ i ][ j ] = max( dp[ i - 1 ][ j ] , dp[ i - 1 ][ j - price[ i ] ] + weight[ i ] )可以发现每个新的i都只用了dp[ i - 1 ]的 第0 ~ n位，dp[i - 1]之前的全部没用了，索性这里只开一个一维数组dp[j]每次取dp[0] ~ dp[n]的值运算并覆盖先前的值。

　　新的状态转移方程：dp[ j ] = max(dp[ j ], dp[ j -  price[[ i ] ] + weight[[ i ])

　　初始话边界状态为购买前0袋大米，重量为0，之后枚举所有大米种类，并逆序枚举资金之后寻找其最大值便可以得到答案。

```c++
#include <bits/stdc++.h>
using namespace std;
const int maxn = 100 * 21;
int price[maxn];
int weight[maxn];
int dp[maxn];
int main(){
    int d;    //d为测试组数 
    while(scanf("%d", &d) != EOF){
        while(d--){
            int n, m;
            scanf("%d%d", &n, &m);    //输入资金数量与大米种类 
            int cnt = 1;
            for(int i = 1; i <= m; i++){
                int mey, wit, num;
                scanf("%d%d%d", &mey, &wit, &num);
                //输入每种大米的价格质量库存 
                while(num--){    //拆分大米为单袋 
                    weight[cnt] = wit;
                    price[cnt] = mey;
                    cnt++;    //j记录总袋数 
                }
            }
            cnt--;
            memset(dp, 0, sizeof(dp));//初始化所有情况最大重量为0 
            for(int i = 1; i <= cnt; i++){    //遍历所有大米 
                for(int j = n; j >= price[i]; j--){    //逆序遍历所有资金的情况 
                    dp[j] = max(dp[j], dp[j - price[i]] + weight[i]);
                    //状态转移方程 
                }
            }
            int ans = 0;
            for(int i = 0; i <= n; i++){
                ans = max(ans, dp[i]);    //找到最大值 
            }
            printf("%d\n", ans);
        }
    }
}
```

