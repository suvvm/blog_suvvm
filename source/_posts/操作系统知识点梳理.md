---
title: 操作系统理论梳理
date: 2019-12-17 22:00:50
categories: 
- 理论归纳
tags:
- 操作系统
mathjax: true
---

# OS理论梳理

[TOC]

## 3大基本操作系统（批处理、实时、分时）的主要特点

### 批处理操作系统

#### 特点

- 系统资源利用率高
- 系统吞吐量大
- 平均周转时间长
- 无交互能力

#### 工作方式

1. 用户将作业交给系统操作员
2. 系统操作员将许多用户作业组成一批作业，输入到计算机系统中，在系统中形成一个自动转接的连续作业流
3. 启动操作系统
4. 系统自动、依次执行每个作业
5. 由操作员将作业结果交给用户

#### 追求目标

提高资源利用率，增加作业处理吞吐量

#### 批处理系统中的作业

- 用户程序
- 数据
- 作业说明书

#### 成批

通常由若干个作业组成，用户提交作业后只能等待处理结果，不能干预自己作业的执行

#### 批作业处理

对一批作业中的每个作业进行相同处理：从磁带读入用户作业和编译链接程序，编译链接用户作业生成可执行程序；启动执行；执行并输出结果

#### 问题

慢速的输入输出处理直接由主机来完成，输入输出时，cpu处于等待状态

#### 解决方案

卫星机：由卫星机完成面向用户的输入输出（纸带），中间结果暂存在磁带或磁盘上

#### 批处理方式

- 单道批处理
- 多道批处理

#### 实现

spooling系统：利用磁盘作缓冲，将输入、计算、输出分别组织成独立的任务流，使I/O真正并行

现代计算机打印通常也采用spooling技术

### 分时操作系统

最早的交互式操作系统

#### 工作方式

一台主机为多个没有计算能力的终端服务，由终端输入命令，主机进行回答

#### 特点

- 独立性
- 多路性
- 交互性
- 及时性

#### 时间片

操作系统将cpu的时间划分为若干个片段，称为时间片

- 操作系统以时间片为单位，轮流为每个终端用户服务，每次服务一个时间片
- 利用人的错觉使用户感觉不到计算机在服务他人

#### 追求目标

及时响应（依据响应时间：从终端发出命令到系统给出回答所经历的时间）

#### 通用操作系统

分时系统于批处理系统结合

原则：分时优先，批处理在后 "前台":需要频繁交互的作业；"后台":时间性要求不强的作业

### 实时操作系统

计算机能及时响应外部事件请求，在规定的严格时间内完成对该事件的处理，并控制所有实施设备和实时任务协调一致工作

#### 特点

- 可靠性
- 独立性
- 多路性
- 交互性
- 及时性

#### 分类

- 实时过程控制

  工业控制、航空、军事控制

- 实时通信处理

  电讯、银行、飞机订票、股市行情

#### 追求目标

- 对外部请求在严格时间范围内做出响应
- 高可靠性
  - 硬实时系统（某个动作必须在某个时刻或时间内完成）
  - 软实时系统（接受偶尔违反最终时限）

## 什么是进程，引入进程的目的，进程的特征

### 进程的定义

进程是具有独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的独立单位

总结如下

1. 进程是程序的一次执行
2. 进程是一个程序及其数据在处理机上顺序执行时所发生的活动
3. 进程是具有独立功能的程序在一个数据集合上运行的过程，是系统进行资源分配和调度的独立单位

### 引入进程的目的

为了使程序能够并发执行，并且可以对并发执行的程序加以描述与控制。

### 进程的特征

1. 动态性：进程的实质是进程实体的执行过程，因此动态性是进程最基本特征
2. 并发性：多个进程实体同时存在与内存中，且能在同一时间运行。
3. 独立性：进程实体是能独立运行、独立获取资源、独立接受调度的基本单位
4. 异步性：进程是按异步方式运行的，即按各自独立不可预知的速度向前推进（可进行同步配置）

## 进程的所有状态及状态转换

- 运行态

  占有CPU，并在CPU上运行

- 就绪态

  进程已经具备运行条件，但由于没有空闲CPU暂时无法运行

- 等待态（阻塞态）

  因为等待某一事件而暂时不能运行（如读盘）

- 其他状态

  - 创建态 已完成创建进程所必要的工作但尚未同意执行该进程（如资源有限）
  - 终止态 终止执行后进程进入的状态，此时可完成一些数据统计工作与资源回收
  - 挂起态 就绪挂起与阻塞挂起 拥有调节负载，进程不占用内存空间，进程映像交换至磁盘上（不在五状态模型中）

### 状态转换

- 就绪$\rightarrow$运行：调度程序选择新的进程运行
- 运行$\rightarrow$就绪
  - 运行进程用完时间片
  - 被更高优先级的进程抢占
- 运行$\rightarrow$阻塞：当一个进程发送某些事件时
  - 请求OS服务
  - 对资源的访问尚不能进行
  - 等待I/O结果
  - 等待另一进程提供信息
- ……

## PCB 进程描述符（进程属性）

用于管理进程的专门的数据结构，记录进程的各种属性，描述进程的动态变化过程

PCB是系统感知进程存在的唯一标志，进程于PCB一一对应

进程表：所有进程PCB的集合

### PCB所包含的信息

- 进程描述信息
  - 进程标识符（process ID）唯一，通常为一个整数
  - 进程名 不唯一，通常基于可执行文件名
  - 用户标识符（user ID）
  - 进程组关系
- 进程控制信息
  - 当前状态
  - 优先级
  - 代码执行入口地址
  - 程序磁盘地址
  - 运行统计信息
  - 进程间同步于通信
  - 进程的队列指针
  - 进程的消息队列
- 所拥有的资源和使用情况
- CPU现场信息

### 进程队列

- 操作系统为每一类进程建立一个或多个队列
- 队列元素为PCB
- 伴随进程状态的改变，其PCB从一个队列进入另一个队列（如就绪队列、等待队列）

### 进程控制

控制进程操作完成进程各状态之间的转换，由具有特定功能的原语完成

- 进程创建原语

- 进程撤销原语

- 阻塞原语

- 唤醒原语

- 挂起原语

- 激活原语

- 改变优先级

- ……

  原语执行过程中不允许被中断

### 进程的分类

- 系统进程/用户进程
- 前台进程/后台进程
- cpu密集型进程/io密集型进程

UNIX存在进程家族树，init为根，Windows虽然也是一个进程创建另一个进程但是他们地位相同。

### 进程与程序的区别

- 进程能更准确刻画并发，而程序不能
- 程序只是一组有序指令的集合，是静态的，进程是动态的
- 进程有生命周期，是短暂的；程序是长久的
- 一个程序可以对应多个进程
- 进程具有创建其他进程的功能



## 引入线程的目的，线程的特征

### 引入线程的目的

- 应用的需要

- 开销的考虑

  线程的开销小，两个线程切换花费时间少，线程间通讯无限调用内核

- 性能的考虑

  - 充分发挥多处理器优势

例如构造服务器（应用的需要）

多线程：有并发、阻塞系统调用

单线程进程：无并发、阻塞系统调用

有限状态机：有并发、非阻塞系统调用、中断

### 线程的基本概念

线程继承了进程的两个基本属性中的一个（资源的拥有者，**cpu的调度单位**），线程是cpu的调度单位。

所以线程是进程中的一个运行实体，是CPU的调度单位，有时将线程称为轻量级进程

### 线程的特征（属性）

- 标识符 ID

- 有状态及状态转换

- 不运行时需要保存的上下文

  有上下文环境：程序计数器等寄存器

- 有自己的栈和栈指针

- **共享所在进程的地址空间和其他资源**

- 线程可以创建、撤销另一个线程，程序开始是是单线程的方式运行的。

#### 用户级线程 

- 在用户空间建立线程库：提供一组管理线程的过程
- 运行时系统：完成线程的管理工作（操作、线程表 创建、线程数据结构管理）
- 内核管理的还是进程，不知道线程的存在
- 线程切换不需要内核态权限

 ##### 优点

- 线程切换快
- 调度算法是应用程序特定的
- 用户级线程可运行在任何操作系统上（只需实现线程库）

##### 缺点

- 内核只将处理器分配给进程，同一进程中的两个线程不能同时运行于两个处理器上
- 大多数系统调用是阻塞的，因此、由于内核阻塞进程，故进程中所有线程也被阻塞

#### 核心级线程

- 内核管理所有线程，并向应用程序提供API接口
- 内核维护进程和线程的上下文
- 线程的切换需要内核支持
- 以线程为基础进行调度

## 处理机的调度层次（高级、中级、低级）及典型应用

### 作业调度（高级调度）

按照一定原则从外部存储器中处于后备队列选择作业调入内存，并为它们创建进程，分配必要资源后调入就绪队列。

- 应用：批处理系统
- 执行频率较低，通常几分钟一次

### 内存调度（中级调度）

将暂时不能运行的进程调至外存等待，此时进程状态为挂起态，当它们已经具备了运行条件且内存有空闲由内存调度决定是否将其调入内存，并修改状态为就绪态

- 应用：解决内存紧张问题，提高内存利用率和系统吞吐量，完成了存储器管理中的对换功能

### 进程调度（低级调度）

根据某种算法决定就绪队列中哪个进程获得处理机

- 是OS中最基本的调度
- 频繁使用（毫秒级）要求高效
- 通常有抢占非抢占两种方式

## 死锁定义，产生死锁的必要条件，预防死锁的方法

### 死锁定义

一组进程中，每个进程都无限等待被该组进程中另一组进程所占有的资源，因而永远无法得到资源，这种现象称为进程死锁，这组进程称为死锁进程。

### 产生死锁的必要条件

- 互斥使用（资源独占）

  一个资源每次只能给一个进程使用

- 占有且等待（请求和保持，部分分配）

  进程在申请新的资源的同时保持对原有资源的占有

- 不可抢占（不和剥夺）

  资源申请者不能强行的从资源占有者手中夺取资源，资源只能由占有者资源释放

- 循环等待

  存在一个进程等待队列{P1, P2,…, Pn}，其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个等待环路

### 死锁预防

破坏产生死锁的四个必要条件之一

#### 破坏资源独占

- 资源转换技术：把独占资源变为共享资源
- SPOOLing技术：解决不允许任何线程直接占用不可抢占资源的问题，设计一个”守护进程/线程“负责管理不可抢占资源，进程需要使用不可抢占资源时，向守护进程/线程发送请求，由它来完成对应任务

#### 破坏占有且等待

- 在每个进程运行前必须一次性申请所要求的所有资源，当且仅当该进程所要资源均可满足时才给予一次性资源分配
  - 问题：资源利用率低；容易产生”饥饿“现象
- 在允许进程动态申请资源的前提下规定，一个进程在申请新的资源不能立刻得到满足而变为等待状态之前，必须释放已占有的全部资源，若需要再重新申请

#### 破坏不可抢占条件

- 当一个进程申请的资源被其他进程占用时，可以通过操作系统抢占这一资源（优先级）
- 局限性：适用于状态易于保存和恢复的资源(CPU 内存)

#### 破坏循环等待条件

- 通过定义资源类型的线性顺序实现

- 实施方案：资源有序分配法

  把系统中所有资源编号，进程在申请资源时必须严格按资源编号的递增次序进行，否则操作系统不予分配

- 要考虑如何编号（如按使用频率）

- 实现方法：让当前占有编号最大的进程继续执行（之后的编号肯定没有分配）

### 解决死锁的方法

- 不考虑死锁（鸵鸟算法）

- 不让死锁发生

  - 死锁预防 

    静态策略：设计合适的资源分配算法，不让死锁发生

  - 死锁避免

    动态策略：以不让死锁发生为目标，跟踪并评估资源分配过程，根据评估结果决策是否分配资源

- 让死锁发生

  死锁检测与解除

## 虚拟存储器的定义、特征

### 虚拟存储器定义

是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储系统

- 把内存与磁盘有机结合使用从而得到一个容量很大的”内存“，就是虚拟存储器
- 虚拟存储器是对内存的抽象，构建在存储体系之上，由操作系统协调各存储器的使用
- 虚拟存储器提供了一个比物理空间大得多的地址空间

### 虚拟存储器特征

- 多次性

  无需在程序运行时一次性将其全部调入内存，而是被分为多次调入内存运行

- 对换性

  在程序运行中无需一直常驻内存，而是在运行过程中进行换进与换出

- 虚拟性

  从逻辑上扩充内存容量，使用户看到的内存容量远大于实际内存容量

### 实现方式

- 分页请求系统
- 分段请求系统

## 内存的连续分配方式和离散分配方式的种类特点和不同

 ### 连续分配

为一个用户程序分配一个连续的内存空间，程序中代码或数据的逻辑地址相邻

#### 连续分配的方式

- 单一连续分配

  内存分为系统区与用户区，用户区被一个程序独占

- 固定分区分配

  将整个用户空间划分为若干固定大小的区域，每个区域被一个程序独占

- 动态分区分配

  根据进程实际需要动态地为之分配内存空间。

- 基于顺序搜索的动态分区分配

  将系统中的空闲分区链接成一个栈，依次搜索空闲分区链上的空闲分区，来找到合适的分区

连续分配方式会形成许多“碎片”虽然可以拼接但开销很大

### 离散分配

#### 离散分配方式

允许将一个进程直接分散装入到许多不同内存分区中。

- 分页存储管理方式

  将用户程序地址空间分为若干固定大小的区域，称为页或页面，相应的也将内存空间分为若干个物理块或页框，页和块大小相同，可将用户程序的任一页放在任一物理块中

- 分段存储管理方式

  把用户程序地址空间分为若干大小不同的段，每段可定义一组完整的信息，在存储器分配时，以段为单位，这些段在内存中可以不相连

- 段页式存储管理方式

  分页与分段结合，既有两者优点，是应用较为广泛的一种存储管理方式

## 缓冲的引入原因，缓冲的分类

### 缓冲的引入

- 缓和CPU与IO设备之间速度不匹配的矛盾
- 减少对CPU的中断频率，放宽对CPU中断响应实际的限制
- 解决数据粒度不匹配问题
- 提高CPU和IO设备之间的并行性

### 缓冲的分类

- 单缓冲区

  每当用户进程发出一IO请求，操作系统便在主存中为之分配一个缓冲区

- 双缓冲区

  （由于缓冲区是共享资源，生产者和消费者在使用缓冲区时必须互斥，如果消费者尚未取走缓冲区中的数据，即使生产者又生产出新的数据，也无法将它送入缓冲区，所以为消费者生产者设置两个缓冲区）

  双缓冲区（缓冲对换）在设备输入时，先将数据送入第一缓冲区，装满后转向第二缓冲区，此时操作系统可以从第一缓冲区中移出数据，并送入用户进程。

- 环形缓冲区（多缓冲区）

  （生产者与消费者之间速度差距明显）环形缓冲区中有多个缓冲区，可以分为三种

  - 空缓冲区R
  - 满缓冲区G
  - 消费者正在使用的缓冲区C

  作为输入的缓冲区可以设置三个指针

  - Nextg：指示消费者可以使用的下一个满缓冲区
  - Nexti：指示生产者可以使用的下个空缓冲区
  - Current：指示消费者正在使用的缓冲区

  环形缓冲区的使用

  - Getbuf ：
    - 消费者：
      1. 将Nextg所指向的缓冲区交给消费者Current使用
      2. Nextg移向下一个满缓冲区
    - 生产者：
      1. 将Nexti所指的缓冲区交给生产者使用
      2. 将Nexti移向下一个空缓冲区
  - Releasebuf
    - 消费者将缓冲区中数据提取完：将先行工作缓冲区C改为空缓冲区R
    - 生产者把缓冲区装满：将缓冲区释放并改为G缓冲区

- 缓冲池

  （当系统较大时应该会有许多环形缓冲区，不仅要消耗大量内存空间，而且利用率不高，可以用公共缓冲池解决）

  缓冲池管理着多个缓冲区

  **缓冲区组成**

  - 缓冲首部：

    用于标识和管理，包括缓冲区号、设备号、设备上的数据块号、同步信号量、队列链接指针

  - 缓冲体：用于存放数据

  为了方便管理将缓冲池中具有相同类型的缓冲区链接成一个队列每个队列有队首指针F与队尾指针L

  1. 空白缓冲队列

     由空缓冲区组成

  2. 输入队列

     由装满输入数据的缓冲区组成

  3. 输出队列

     由装满输出数据的缓冲区组成


## 四种I/O设备控制方式，各自的工作原理和它们之间的不同

### 程序控制I/O（查询方式）

由CPU代表进程向I/O模块发送I/O命令，不断询问设备控制器状态，进程进入忙等待，直到操作完成才继续执行

![img](操作系统知识点梳理\程序控制IO.JPG)

### 中断驱动I/O

为了减少设备驱动程序不断询问控制器状态寄存器的开销，当正设备在执行某一I/O操作时，CPU可以根据需要转去执行另一程序，I/O操作结束后，由设备控制器主动通知设备驱动程序

![img](操作系统知识点梳理\中断驱动IO.JPG)

### DMA（直接存储器访问）

允许主存储器和I/O设备之间通过“DMA控制器(DMAC)”直接进行批量数据交换，除了在数据传输开始和结束时，整个过程无须CPU的干预。每传输一个“块”数据只需要占用一个主存周期。

![img](操作系统知识点梳理\DMA.JPG)

### 通道

通道是负责外围设备与主存之间进行 数据交换、能单独完成输入输出操作的**处理机**，它控制设备与内存直接进 行数据交换。它有自己的通道指令， 这些通道指令的运行由CPU启动，并 在操作结束时向CPU发出中断信号。

通道所需要的CPU控制更少，一个通道可以控制多个设备，并且能够一次进行多个不连续的数据块的存取交换.

#### 通道的类型

- 字节多路通道
- 选择通道
- 数组多路通道

## 利用记录型信号量机制：P（wait(s)）V（signal(s)）解决进程同步问题

### 采用信号量的目的

- 同步
- 互斥
- 描述前驱关系

设公共汽车上，司机活动是：启动车辆、正常行车、到站停车；售票员的活动是：关车门、售票、开车门。在汽车不停的到站、停战、行驶过程中，这两个活动有什么同步关系？用信号量P、V操作实现它们的同步

```c++
semaphore s1 = 0;	// 车门
semaphore s2 = 0;	// 车辆状态
main(){
    driver();
    busman();
}
driver{
    while(true){
        P(s1);
        启动车辆;
        正常行车;
        到站停车;
        V(s2);
    }
}
busman(){
    while(true){
        关闭车门;
        V(S1);
        售票;
        P(S2);
        开启车门;
    }
}

```



某寺庙，有小和尚、老和尚若干，有一缸水，有小和尚提水入缸供老和尚引用。水缸可容10桶水，水取自同一井中。水井颈窄，每次只能容一个桶取水。水桶总数为3个。每次入、取缸水仅为1桶，且不可同时进行。试用P、V操作给出取水、入水的算法描述。

```c
semaphore cnt = 3;	// 桶
semaphore mutexg = 1;	// 缸
semaphore mutexj = 1;	// 井
semaphore full = 0;	// 满
semaphore empty = 10;	// 空
main(){
    put();
    pop();
}
put(){
    P(cnt);
    P(mutexj);
    P(empty);
    取水
    V(mutexj);
    P(mutexg);
    倒入缸;
    V(full);
    V(cnt);
    V(mutexg);
}
pop(){
    P(cnt);
    P(mutexg);
    P(full);
    喝水;
    V(empty);
    V(cnt);
    V(mutexg);
}
```



爸爸专向盘中放苹果，妈妈专向盘中放橘子，儿子专等吃盘里的橘子，女儿专等吃盘里的苹果。只要盘子空，爸爸妈妈可向盘中放水果，仅当盘中有自己需要的水果时，儿子或女儿可从中取出，请给出他们四人之间的同步关系，并用PV操作实现四人正确活动的程序。。使用p、v操作来完成父亲、妈妈、儿子、女儿的同步行为模拟。

```c++
semaphore pan = 1;	// 盘子容量1
semaphore apple = 0;
semaphore orange = 0;
main(){
    father();
    mother();
    son();
    daughter();
}
father(){
    P(pan);
    放入苹果;
    V(apple);
}
mother(){
    P(pan);
    放入橘子;
    V(orange);
}
son(){
    P(orange);
    吃橘子
    V(pan);
}
daughter(){
    P(apple);
    吃苹果
    V(pan);
}
```



假定生产者和消费者之间的公用缓冲池中具有n个缓冲区，这时可利用互斥信号量mutex实现诸进程对缓冲池的互斥使用；利用信号量empty和full分别表示缓冲池中空缓冲区和满缓冲区的数量。又假定这些生产者和消费者相互等效，只要缓冲池未满，生产者便可将消息送入缓冲池；只要缓冲池未空，消费者便可从缓冲池中取走一个消息，对生产者-消费者问题可描述如下

```c++
semaphore empty = n;	// 空缓冲区
semaphore full = 0;	// 满缓冲区
semaphore mutex = 1; // 缓冲池

main(){
	producter();
	consumer();
}
producter(){
	whille(true){
		P(empty);
		P(mutex);
		将消息送入缓冲池;
		V(mutex);
		V(full);
	}
}
consumer(){
	while(true){
		P(full);
		P(mutex);
		将消息取出
		V(mutex);
		V(empty);
	}
}
```



## 计算相关作业调度算法的完成时间、周转时间、带权周转时间

- $ 周转时间 = 完成时间 - 到达时间$
- $ 带权周转时间 = \frac {周转时间}{服务时间}$
- $ 平均周转时间 = \frac {周转时间}{进程数}$
- $ 平均带权周转时间 = \frac {带权周转时间}{进程数}$

### FCFS先来先服务

按照作业提交或进程变为就绪状态的顺序分派CPU，当前作业或进程占用CPU直到执行完或阻塞才让出CPU

- 优点
  - 有利于长作业
  - 有利于CPU繁忙的作业
- 缺点
  - 不利于短作业
  - 不利于I/O繁忙的作业

### 短作业优先

对预计执行时间最短的作业或进程优先分派处理机，通常后来的作业不抢占正在执行的作业

- 优点
  - 比FCFS改善平均周转时间和平均带权周转时间
  - 缩短短作业等待时间
  - 提高系统吞吐量
- 缺点
  - 对长作业不利，可能产生饥饿现象
  - 未能根据作业的紧迫程度划分执行优先级
  - 实际操作中进程的执行时间难以准确估计

### 最高优先级优先

为每个作业或进程引入优先权，对优先权高的作业或进程优先分配处理机

分为抢占式与非抢占式两种

优先级有静态优先级与动态优先级两种

- 静态优先级
  - 用户根据作业紧急程度输入
  - 由系统或操作员根据作业类型指派优先级
  - 根据作业要求资源情况确定优先级
- 动态优先级
  - 根据进程占有CPU时间的长短决定
  - 根据就绪进程等待CPU的时间长短来决定

### 时间片轮转

将系统中所有的就绪进程按FCFS排成队列，每次调度将处理机分配给队首元素，让其执行一个时间片，时间片结束后发生时钟中断，调度程序将队首进程送至就绪队列的末尾后将处理机分配给当前队首元素。

每个进程在就绪队列中的等待时间与享受服务的时间成正比例

## 避免死锁：银行家算法（要求给出全步骤计算）

由Dijkstra于1965年提出

### 使用条件

- 在固定数量进程中共享固定数量的资源
- 每个进程预先指定完成工作所需的最大资源量
- 进程不能申请比系统中可用资源总数还多的资源
- 进程等待资源的时间是有限的
- 如果系统满足了进程对资源的最大需求，那么，进程应该在有限的时间内使用资源，然后归还给系统

### 进程资源申请步骤

- 申请资源若大于该进程最大资源量，报错返回
- 申请的资源大于系统当前持有可分配资源量，进程等待
- 进行假设分配
- 判断假设分配后系统处于安全状态，则分配完成
- 若系统处于不安全状态，恢复原来状态，进程等待

### 安全状态判断

- 寻找当前可以系统可分配资源满足的进程
- 若找到满足的进程，将该进程占有的资源假设归还给系统，寻找下一个进程
- 所有进程都被处理则证明当前状态安全
- 若找不到这种进程且并未处理完所有进程，证明该状态不安全

## 动态分区分配方式的分配算法，分区的分配和释放过程

### 单一连续分区

同一时间只能由一个进程在内存内，内存利用率低

### 固定分区分配

- 把内存空间分割为若干区域
- 每个分区大小可以相同也可以不同
- 分区大小固定不变
- 每个分区能且只能装一个进程

存在外碎片

#### 碎片问题解答

紧缩技术(压缩技术)

将所有小的分区合并为较大的空闲区

### 动态分区

- 根据进程的需要，把内存空闲空间分割出一个分区分配给该进程
- 剩余空闲部分称为新的空闲分区

#### 首次适应算法

将空闲分区连以地址递增的形式链接，在内存分配时，从链首开始查找，直到找到一颗分区大小可以满足需求，按该作业大小分配内存，剩余的空闲分区仍在空闲分区链中。

#### 最佳适应算法

将空闲分区链中的空闲分区按大小由小到大排序，每次从链首进行查找，直至找到何合适的空闲分区，每次找到的分区是与作业大小最接近的

#### 下次适应算法

第二个进程从第一个进程分配的分区开始查找，抵达结尾返回开头

#### 最坏适应算法

用满足作业空间需求的最大分区进行分割

#### 内存回收

当某一分区归还后，将前后的空闲空间合并，并修改内存空闲表

四种相邻的情况

- 上相邻
- 下相邻
- 上下相邻
- 上下都不相邻

### 伙伴系统

将系统中的空闲分区根据其大小进行分类，相同大小的分区单独建立一个空闲分区双向链表

当需要为进程分配长度为n的存储空间时，首先计算一个i值，使$2^{i-1}<n ≤ 2^i$ ，然后查找空闲分区大小为$ 2^i $ 的空闲链表，若找到进行分配，若没找到，则在分区大小为 $ 2^{i+1}$的空闲分区链表中查找，若找到一个空闲分区，则把该分区分为相等的两个分区，这两个分区称为一对伙伴，其中一个分区用于分配，而把另一个加入分区大小为$2^i$的空闲分区链表中

## 在分页系统中，如何分址？如何根据逻辑地址计算页号和页内偏移量，并转换物理地址？

### 分址方式

用户进程地址空间被划分成大小相等的部分，称为页，从0开始编号，页大小为2的幂通常为1KB~8KB

内存空间按同样大小被划分为大小相等的页，称为页框，从0开始编号

内存分配时以页为单位进行分配，逻辑上相邻的页在物理上不一定相邻

逻辑地址格式： （32位）如4KB页面最多1M页：页号（20） + 页内偏移（12位）

页表中保存着页号和内存块号的映射

### 根据逻辑地址计算页号和页内偏移量并转换物理地址

#### 计算页号和页内偏移量

- 根据给定的页面大小计算页号长度
- 将给定的逻辑地址转换为二进制
- 计算页号和页内偏移

对某特定机器，其地址结构是一定的。若给定一个逻辑地址空间中的地址为A，页面的大小为L，则页号P和页内地址d可按下式求得

$P=INT[\frac AL]$

$d = [A]\ MOD\ L$

#### 转换物理地址

根据页号查询页表，找到对应页的物理地址$(块号 \times 页大小)$，物理地址加上页偏移量就是物理地址

## 根据页面置换算法，计算置换页面、缺页次数、缺页率

### 最佳置换算法（OPT）

从内存中移出永远不在需要的页面，如果不存在，则移除在最长(未来)时间内不再被访问的页面

#### 最近最久未使用（LRU）置换算法

选择最近最久未使用的页面予以淘汰。该算法为每个页面赋予一个访问字段，用来记录一个页面自上次被访问以来所经历的时间t

![img](操作系统知识点梳理\LRU1.JPG)

利用栈来保存当前使用的各页面页号。当要访问某页面时，便将该页的页号从栈中移出，将它压入栈顶

![img](操作系统知识点梳理\LRU栈.JPG)

### 先进先出置换算法（FIFO）

当需要淘汰一个页面时，总是淘汰内存中存在时间最长的页面

### 缺页率

$缺页率 = \frac {缺页次数}{访问次数}$

## 磁盘存储空间的分配，磁盘调度算法解决访问序列以及访问的时间

### 连续分配方式

为每一个文件分配一组相邻接的盘块

在采用连续组织方式时，可把逻辑文件中的记录顺序地存储到邻接的各物理盘块中，这样所形成的文件结构称为顺序文件结构，此时的物理文件称为顺序文件。

#### 优点

- 顺序访问容易
- 顺序访问速度快

#### 缺点

- 只能为一个文件分配连续的存储空间
- 必须事先知道文件的长度
- 不能灵活地删除和插入记录
- 不能灵活处理动态增长的文件

### 链接分配方式

一个文件的信息存放在若干个不连续的物理块中，各块之间通过指针连接，前一个物理块指向下一个物理块。fat中每个文件同样只需要一项，包括文件名、起始块号和最后块号。任何一个自由块都可以加入到链中。

#### 显式连接

这是指把用于链接文件各物理块的指针显式地存放在内存的一张链接表中

#### 隐式链接

这是指把用于链接文件各物理块的指针存放在磁盘上的一张链接表中

#### 优点

- 提高磁盘的空间利用率，不存在外部碎片问题
- 有利于文件的插入和删除
- 有利于文件的动态扩充

#### 缺点

- 存取速度慢，一般只适用于信息的顺序存取，不适于随机存取
- 查找某一块必须从头到尾沿着指针进行
- 可靠性问题（只要一个指针出错就会出现可怕问题）
- 更多的寻道次数和寻道时间
- 链接指针占一定的空间，将多个块组成簇，按簇进行分配而不是按块进行分配

### 索引分配方式

每个文件在FAT中有一个一级索引，索引包含分配给文件的每个分区的入口。文件的索引保存在单独的一个块中，FAT中该文件的入口指向这一块

#### 优点

- 索引分配支持顺序访问文件和直接访问文件
- 满足了文件动态增长，插入删除的要求
- 能充分利用外存空间

#### 缺点

- 较多的寻道次数和寻道空间
- 索引表本身带来了系统开销

### 磁盘调度算法

#### 先来先服务算法（FCFS）

根据进程请求访问磁盘的先后次序进行调度

##### 优点

- 公平、简单，且每个进程的请求都能依次得到处理
- 不会出现某一进程的请求长期得不到满足的情况

##### 缺点

- 未对寻道进行优化，在对磁盘的访问请求比较多的情况下，此算法将降低设备服务的吞吐量



#### 最短寻道时间优先算法（SSTF）

访问的磁道与当前磁头所在的磁道距离最近，以使每次的寻道时间最短

##### 优点

- 可以得到比较好的吞吐量

##### 缺点

- 不能保证平均寻道时间最短
- 对用户的服务请求的响应机会不是均等的
- 响应时间的变化幅度很大
- 内外边缘磁道的请求将会无限期的被延迟，有些请求的响应时间将不可预期

#### 扫描算法（SCAN）（电梯调度）

不仅考虑到欲访问的磁道与当前磁道的距离，更优先考虑的是磁头的当前移动方向

例如，当磁头正在自里向外移动时，扫描算法所选择的下一个访问对象应是其欲访问的磁道既在当前磁道之外，又是距离最近的，这样自里向外地访问，直到最边缘磁道才将磁臂换向，自外向里移动。

##### 优点

- 避免了饥饿现象的出现
- 吞吐量较大，平均响应时间较小

##### 缺点

- 摆动式的扫描方法，两侧磁道被访问的频率仍低于中间磁道

#### 循环扫描算法（CSCAN）

循环扫描算法规定磁头单向移动。例如，只自里向外移动，当磁头移到最外的磁道时，磁头立即返回到最里的磁道

#### LOOK

当磁头正在自里向外移动时，扫描算法所选择的下一个访问对象应是其欲访问的磁道既在当前磁道之外，又是距离最近的，这样自里向外地访问，直到再无更外的磁道需要访问才将磁臂换向，自外向里移动。

##### 优点

#### CLOOK

循环扫描算法规定磁头单向移动。例如，只自里向外移动，当磁头移到最外的**欲**被访问磁道时，磁头立即返回到最里的**欲**访问磁道