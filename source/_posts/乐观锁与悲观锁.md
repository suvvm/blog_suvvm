---
title: 乐观锁与悲观锁
date: 2020-04-20 13:09:25
categories: 
- 理论归纳
tags:
- 事务
- 数据库
- 锁
---

# 乐观锁与悲观锁

乐观锁与悲观锁是一种设计思想，不止存在于数据库中，而广泛应用于各种方面。

## 乐观锁

### 乐观锁的思想

默认总是认为数据更新是不会发生冲突，开始更新数据时不对数据加锁，而是在提交更新时进行验证，判断本次更新提交之前是否有其它的更新操作已被提交。

### 乐观锁的应用场景

乐观锁适用于写操作较少的情况，省去了加锁的开销，提升了吞吐量。（阿里巴巴开发规范上提到过并发量不高，失败几率不超过20%推荐使用CAS更新）

### 乐观锁的实现方式

- 版本号机制

  为目标数据添加一个版本号version字段（或时间戳timestamp），表示数据被更新的次数，当数据被修改时，其版本号会发生改变，若某次更新提交之前发现版本号于提交前相比有变动，则拒绝该次更新提交并尝试重新进行更新操作，直到版本号不变。

- CAS算法（compare and swap）

  CAS算法包含3个操作数

  - 内存位置V
  - 预期原值A
  - 目标更新值B

  每当尝试更新每个值时，都会检测其内存位置的值V是否与预期原值A相等，相等证明更新提交之前该值没有被其他并发任务改变，可以提交，否则拒绝提交，并更新预期原值A

  CAS的问题

  - ABA 

    可能有一个任务读取的V为A这时另一个任务将V修改为B又修改为A，第一个任务提交时就会误认为V没有发生改变重新提交（可以通过版本号解决）

## 悲观锁

### 悲观锁的思想

默认总是认为数据更新会发生冲突，所以直接对目标数据加锁以解决并发问题

### 悲观锁的应用场景

在并发任务数较多，乐观锁失败几率较大的情况下使用悲观锁

### 悲观锁的实现方式

每当尝试更新数据时都将尝试对目标数据加排它锁：[InnoDB中的锁](https://www.suvvm.work/2020/04/18/InnoDB中的锁/)

### MySQL InnoDB加锁方式

#### 两段锁协议

将事务的加锁过程分为了两个阶段，第一阶段为加锁阶段，第二阶段为解锁阶段，保证了事务的串行化

- 加锁阶段

  在事务开始后到提交或回滚前都处于加锁阶段

- 放锁阶段

  当事务开始回滚或提交时进入放锁阶段

### 死锁避免

#### 产生死锁的必要条件

- 互斥使用（资源独占）
- 占有且等待
- 不可抢占
- 循环等待

#### 破坏产生死锁的必要条件

- 破坏互斥使用

  曼彻斯特大学的spooling技术，将独占资源交给守护线程分配有守护线程决定请求的处理方式

- 破坏占有且等待

  - 一次性申请所有资源
  - 不能立刻得到满足则释放已占用资源，若需使用重新申请

- 破坏不可抢占

  利用优先级来抢占目标资源（易于保存和恢复）

- 破坏循环等待

  为资源标号线性分配资源，让当前占有资源标号最大的任务继续执行

#### 解决方式

- 鸵鸟算法

- 保证程序逻辑不产生死锁
- 保证事务轻量，尽早提交事务
- 为事务设置等待超时阈值（InnoDB innodb_lock_wait_timeout）

