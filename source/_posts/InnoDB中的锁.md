---
title: InnoDB中的锁
date: 2020-04-18 15:20:45
categories: 
- 理论归纳
tags:
- 事务
- InnoDB
- 数据库
- 锁
---

# InnoDB中的锁

## 表级锁

MySQL中的表级锁分为两种，读锁和写锁。通过LOCK TABLE name READ/WRITE可以添加读锁，UNLOCK TABLES可以释放锁（事务提交前不要使用UNLOCK TABLES，因为其默认会提交事务）。但是表级锁不由InnoDB存储引擎管理，而是由MySQL Server控制（autocommit=0,innodb_table_lock=1）。

### 表级锁适用情况

- 事务需要更新表中的大量数据，且表也较为庞大
- 事务涉及多个表的操作，较为复杂容易引起死锁

### 表锁的种类

- 读锁

  当某一事务为某一表添加读锁后，其他所有事务无法获取该表的写锁来修改该表内容，但依旧可以继续为该表添加读锁来查询数据。

- 写锁

  当某一事物为某一表添加写锁后，其他所有事务无法获取该表的读锁与写锁，即无权访问该表。

- 意向锁

  为了使表锁与行锁共存而出现的表锁的种类，具体将在行锁中介绍。

### 表锁的实现

维护了四个队列

- 读锁队列中保存当前所有的持有读锁的事务
- 读锁等待队列中保存当前所有等待得到读锁的事务
- 写锁队列中保存当前获得写锁的事务
- 写锁等待队列中保存当前所有等待获得写锁的事务

## 行锁

与表锁的直接由MySQL Server控制不同，行锁由数据库存储引擎自行实现。

### 行锁的种类

- 共享锁

  类似于行的读锁，一个事务读取某行数据时会为该行数据添加共享锁，此时若有其他事务想要并发读取该行时可以再次为该行添加共享锁；若某行存在共享锁时，有并发事务妄图申请该行的排它锁则会被阻塞。

- 排它锁

  类似于行的写锁，一个事务更新某行数据时会为该行添加排它锁，此时将阻塞所有其他申请该行共享锁或排它锁的事务。

### 意向锁

若表种的某行上已经存在共享锁或排它锁，此时有并发事务申请表的写锁，由于对于表来说此时没有写锁的存在，所有可以申请，此时就出现了错误，为了避免这种情况的发生，出现了意向锁。

- 意向共享锁，若某个事务尝试向表中某行添加共享锁时，会首先为该表添加意向共享锁
- 意向排它锁，若某个事务尝试向表中某行添加排它锁时，会首先为该表添加意向排它锁

### 锁的兼容状态

|                | 共享锁 | 排它锁 | 意向共享锁 | 意向排它锁 |
| -------------- | ------ | ------ | ---------- | ---------- |
| **共享锁**     | 兼容   | 不兼容 | 兼容       | 不兼容     |
| **排它锁**     | 不兼容 | 不兼容 | 不兼容     | 不兼容     |
| **意向共享锁** | 兼容   | 不兼容 | 兼容       | 兼容       |
| **意向排它锁** | 不兼容 | 不兼容 | 兼容       | 兼容       |

## InnoBD的加锁方式

- InnoDB将对UPDATE、DELETE、INSERT语句涉及的数据集自动添加排它锁
- SELECT语句可以通过 添加 LOCK IN SHARE MODE添加共享锁，通过添加FOR UPDATE 添加排它锁
- InnoDB的行级锁锁的不是数据项，而是索引项，只有通过索引检索数据时InnoBD才会使用行级锁
- InnoDB有间隙锁的概念，在指定隔离级别下如果是范围性查询，即使没有检索到数据也会对数据间隙加速，防止其他事务操作间隙。